<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>商品的spu、sku及其之间的关系</title>
    <url>/2020/11/13/%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A/%E5%95%86%E5%93%81%E7%9A%84spu%E3%80%81sku%E5%8F%8A%E5%85%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="SPU-标准化产品单元"><a href="#SPU-标准化产品单元" class="headerlink" title="SPU:标准化产品单元"></a>SPU:标准化产品单元</h3><p>SPU = Standard Product Unit （标准化产品单元）,SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</p>
<h3 id="SKU-库存量单位"><a href="#SKU-库存量单位" class="headerlink" title="SKU:库存量单位"></a>SKU:库存量单位</h3><p>SKU=stock keeping unit(库存量单位) SKU即库存进出计量的单位（买家购买、商家进货、供应商备货、工厂生产都是依据SKU进行的），在服装、鞋类商品中使用最多最普遍。 例如纺织品中一个SKU通常表示：规格、颜色、款式。<br>KU是物理上不可分割的最小存货单元。也就是说一款商品，<strong>可以根据SKU来确定具体的货物存量。</strong></p>
<a id="more"></a>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><blockquote>
<p>spu : 属性(不会影响到库存和价格的属性, 又叫关键属性)</p>
</blockquote>
<p>以 <code>HUAWEI MATE 30</code> 为例，HUAWEI MATE 30是这件商品的SPU的名称，其SPU是一组属性的集合：</p>
<p><strong>【主体】</strong> </p>
<table>
<thead>
<tr>
<th>上市年份</th>
<th>2019年</th>
</tr>
</thead>
<tbody><tr>
<td>品牌</td>
<td>华为（HUAWEI）</td>
</tr>
<tr>
<td>上市月份</td>
<td>9月</td>
</tr>
<tr>
<td>入网型号</td>
<td>TAS-AL00</td>
</tr>
<tr>
<td>产品名称</td>
<td>HUAWEI MAT 30</td>
</tr>
</tbody></table>
<p><strong>【存储】</strong> </p>
<table>
<thead>
<tr>
<th>运行内存</th>
<th>6G</th>
</tr>
</thead>
<tbody><tr>
<td>机身存储</td>
<td>128G</td>
</tr>
<tr>
<td>最大存储扩展</td>
<td>256G</td>
</tr>
<tr>
<td>存储卡</td>
<td>NM存储卡</td>
</tr>
</tbody></table>
<p><strong>【基本信息】</strong> </p>
<table>
<thead>
<tr>
<th>机身宽度（mm）</th>
<th>76.1</th>
</tr>
</thead>
<tbody><tr>
<td>机身厚度（mm）</td>
<td>其他</td>
</tr>
<tr>
<td>机身长度（mm）</td>
<td>160.8</td>
</tr>
<tr>
<td>机身重量（g）</td>
<td>其他</td>
</tr>
<tr>
<td>机身材质分类</td>
<td>金属边框</td>
</tr>
<tr>
<td>机身材质分类</td>
<td>玻璃后盖</td>
</tr>
</tbody></table>
<p>还包括<strong>摄像头、数据接口、屏幕、硬件配置</strong>等一系列属性一起构成了一个SPU，这个SPU的名称叫做<code>HUAWEI MATE 30</code> </p>
<h3 id="sku-影响价格和库存的-属性集合-与商品是多对一的关系，即一个商品有多个SKU。"><a href="#sku-影响价格和库存的-属性集合-与商品是多对一的关系，即一个商品有多个SKU。" class="headerlink" title="sku : 影响价格和库存的 属性集合, 与商品是多对一的关系，即一个商品有多个SKU。"></a>sku : 影响价格和库存的 属性集合, 与商品是多对一的关系，即一个商品有多个SKU。</h3><p>如<code>HUAWEI MATE 30</code>有四种颜色（亮黑色、星河银、翡冷翠、罗兰紫）还有两种配置（全网通6+128g、全网通8+128G）<br>那么其一共有（4*2）8个SKU组合，且每个SKU都有不同的库存</p>
]]></content>
      <categories>
        <category>概念解释</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的IO</title>
    <url>/2020/11/14/Golang/IO/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84IO/</url>
    <content><![CDATA[<h3 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h3><ul>
<li><code>os.Args</code>是一个<code>string</code>的切片，用来存储所有的命令行参数</li>
<li><code>flag</code>包的使用，用来解析命令行参数：<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 命令行参数</span><br><span class="line">func test() {</span><br><span class="line">	var b bool</span><br><span class="line">	var path string</span><br><span class="line">	var port int</span><br><span class="line">	// 预处理配置</span><br><span class="line">	flag.BoolVar(&amp;b, "b", false, "print on newline")</span><br><span class="line">	flag.StringVar(&amp;path, "c", "/conf.config", "Specify the configuration file. The default is /conf.config .")</span><br><span class="line">	flag.IntVar(&amp;port, "p", 8080, "Specify the port, the default is 8080")</span><br><span class="line">	// 解析命令行标志</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf("bool is %v\n", b)</span><br><span class="line">	fmt.Printf("path is %s\n", path)</span><br><span class="line">	fmt.Printf("port is %d\n", port)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test()</span><br><span class="line">}</span><br><span class="line">--------------------</span><br><span class="line">./main -c /use/local/conf.config -p 8081 -b true</span><br><span class="line"></span><br><span class="line">bool is true</span><br><span class="line">path is /use/local/conf.config</span><br><span class="line">port is 8081</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h3 id="终端读写"><a href="#终端读写" class="headerlink" title="终端读写"></a>终端读写</h3><ul>
<li><code>os.Stdin</code>：标准输入</li>
<li><code>os.Stdout</code>：标准输出</li>
<li><code>os.Stderr</code>：标准错误输出</li>
</ul>
<h3 id="终端读写示例："><a href="#终端读写示例：" class="headerlink" title="终端读写示例："></a>终端读写示例：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	fmt.Println("我能把字符串输出到控制台")</span><br><span class="line">	fmt.Fprintln(os.Stdout, "我也能把字符串输出到控制台")</span><br><span class="line">	var (</span><br><span class="line">		name  string</span><br><span class="line">		age   int</span><br><span class="line">		score float32</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	// 把字符串格式化到指定变量</span><br><span class="line">	fmt.Sscanf("张三,18,98.5", "%s,%d,%f", &amp;name, &amp;age, &amp;score)</span><br><span class="line">	fmt.Println(name, age, score)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="带缓冲区的读写示例："><a href="#带缓冲区的读写示例：" class="headerlink" title="带缓冲区的读写示例："></a>带缓冲区的读写示例：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	// 带缓冲区的读</span><br><span class="line">	var inputReader *bufio.Reader</span><br><span class="line">	inputReader = bufio.NewReader(os.Stdin)</span><br><span class="line">	fmt.Println("please enter some input:")</span><br><span class="line">	input, err := inputReader.ReadString('\n')</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("input err:\n", err)</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("the input was %s\n", input)</span><br><span class="line">}</span><br><span class="line">------------------------</span><br><span class="line">please enter some input:</span><br><span class="line">123</span><br><span class="line">the input was 123</span><br></pre></td></tr></tbody></table></figure>



<h3 id="文件读写："><a href="#文件读写：" class="headerlink" title="文件读写："></a>文件读写：</h3><ul>
<li><code>os.File</code>封装所有文件相关操作，<code>os.Stdin</code>,<code>os.Stdout</code>, <code>os.Stderr</code>都是<code>*os.File</code></li>
<li>打开一个文件进行读操作： <code>os.Open(name string) (*File, error)</code></li>
<li>关闭一个文件：<code>File.Close()</code></li>
<li>打开一个文件进行写操作：<code>os.OpenFile(“output.dat”,  os.O_WRONLY|os.O_CREATE, 0666)</code></li>
</ul>
<blockquote>
<p>第二个参数：文件打开模式<br><code>os.O_WRONLY</code>：只写、<code>os.O_CREATE</code>：创建文件、<code>os.O_RDONLY</code>：只读、<code>os.O_RDWR</code>：读写、<code>os.O_TRUNC</code>：清空</p>
</blockquote>
<blockquote>
<p>第三个参数：权限控制：r ——&gt; 004、w——&gt; 002、x——&gt; 001</p>
</blockquote>
<h3 id="文件读写操作示例"><a href="#文件读写操作示例" class="headerlink" title="文件读写操作示例"></a>文件读写操作示例</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 带缓冲区的读</span><br><span class="line">func buffRead(rd io.Reader) {</span><br><span class="line">	var bufferReader *bufio.Reader</span><br><span class="line">	bufferReader = bufio.NewReader(rd)</span><br><span class="line">	str, err := bufferReader.ReadString('\n')</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("input err:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("the input was %s\n", str)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 从文件获取输入</span><br><span class="line">func test2() {</span><br><span class="line">	file, err := os.Open("/1.txt")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("open file err:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer file.Close()</span><br><span class="line">	buffRead(file)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test2()</span><br><span class="line">}</span><br><span class="line">-------------------------</span><br><span class="line">the input was 1234567890</span><br></pre></td></tr></tbody></table></figure>

<p>从文件中读取字符串，统计英文、数字、空格以及其他字符的数量:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type charCount struct {</span><br><span class="line">	c      int</span><br><span class="line">	n      int</span><br><span class="line">	spance int</span><br><span class="line">	other  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">	file, err := os.Open("/1.txt")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("open file err:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer file.Close()</span><br><span class="line">	var count charCount</span><br><span class="line">	var inputReader *bufio.Reader</span><br><span class="line">	inputReader = bufio.NewReader(file)</span><br><span class="line">	for {</span><br><span class="line">		str, err1 := inputReader.ReadString('\n')</span><br><span class="line">		if err1 == io.EOF {</span><br><span class="line">			fmt.Printf("read to the end of file\n")</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Printf("read file err:%s", err)</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		ru := []rune(str)</span><br><span class="line">		for _, v := range ru {</span><br><span class="line">			switch {</span><br><span class="line">			case v &gt;= 'a' &amp;&amp; v &lt;= 'z':</span><br><span class="line">				fallthrough</span><br><span class="line">			case v &gt;= 'A' &amp;&amp; v &lt;= 'Z':</span><br><span class="line">				count.c += 1</span><br><span class="line">			case v == ' ':</span><br><span class="line">				count.spance += 1</span><br><span class="line">			case v &gt;= '0' &amp;&amp; v &lt;= '9':</span><br><span class="line">				count.n += 1</span><br><span class="line">			default:</span><br><span class="line">				count.other += 1</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("char num :%d \nspance num :%d\nnumber num:%d\nother num :%d\n", count.c, count.spance, count.n, count.other)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">-------------------------</span><br><span class="line">read to the end of file</span><br><span class="line">char num :547 </span><br><span class="line">spance num :115</span><br><span class="line">number num:11</span><br><span class="line">other num :330</span><br></pre></td></tr></tbody></table></figure>
<p>使用<code>ioutil</code>读取整个文件,并写到指定文件中</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test() {</span><br><span class="line">	inputFile := "/inputfile.txt"</span><br><span class="line">	outputFile := "/outputfile.txt"</span><br><span class="line">	// 一次读完整个文件</span><br><span class="line">	f, err := ioutil.ReadFile(inputFile)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("read file err:%s\n", err)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	str := string(f)</span><br><span class="line">	fmt.Printf("file content:%s\n", str)</span><br><span class="line">	// 这里第三个参数设置输出文件的权限</span><br><span class="line">	err1 := ioutil.WriteFile(outputFile, f, 0x777)</span><br><span class="line">	if err1 != nil {</span><br><span class="line">		fmt.Printf("write file err:%s\n", err1)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读取压缩文件"><a href="#读取压缩文件" class="headerlink" title="读取压缩文件"></a>读取压缩文件</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 读取解压文件示例：</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">	// 1.打开文件</span><br><span class="line">	fName := "go_dev/day7/example5/main/1.gz"</span><br><span class="line">	fi, err := os.Open(fName)</span><br><span class="line">	var r *bufio.Reader</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("open file err:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer fi.Close()</span><br><span class="line">	// 2.gzip读取打开的文件句柄</span><br><span class="line">	grfi, err := gzip.NewReader(fi)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("open gzip failed err:%v\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 3.用bufio.Reader接收gzip读取出的数据</span><br><span class="line">	r = bufio.NewReader(grfi)</span><br><span class="line">	for {</span><br><span class="line">		line, err := r.ReadString('\n')</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Println("Done reading file")</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line">		fmt.Println(line)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 拷贝文件</span><br><span class="line">func copyFile(dstName, srcName string) (written int64, err error) {</span><br><span class="line">	// 打开源文件</span><br><span class="line">	srcFile, err := os.Open(srcName)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("open src file err:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer srcFile.Close()</span><br><span class="line">	// 打开或创建目标文件</span><br><span class="line">	dstFile, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("open dst file err:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer dstFile.Close()</span><br><span class="line"></span><br><span class="line">	return io.Copy(dstFile, srcFile)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	num, _ := copyFile("/2.txt", "/1.txt")</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的json操作</title>
    <url>/2020/11/14/Golang/IO/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84json%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="Json序列化与反序列化"><a href="#Json序列化与反序列化" class="headerlink" title="Json序列化与反序列化"></a>Json序列化与反序列化</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	"encoding/json"</span><br><span class="line">	"fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 反序列化</span><br><span class="line">type User struct {</span><br><span class="line">	UserName string `json:"username"`</span><br><span class="line">	Age      int    `json:"age"`</span><br><span class="line">	Sex      string `json:"sex"`</span><br><span class="line">	Phone    string `json:"phone"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 结构体转json</span><br><span class="line">func structForJson() (jsonStr string) {</span><br><span class="line">	u := &amp;User{</span><br><span class="line">		UserName: "root",</span><br><span class="line">		Age:      18,</span><br><span class="line">		Sex:      "男",</span><br><span class="line">		Phone:    "13160000001",</span><br><span class="line">	}</span><br><span class="line">	j, err := json.Marshal(u)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("struct for json err:%v\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	jsonStr = string(j)</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// json转结构体</span><br><span class="line">func jsonForStruct() {</span><br><span class="line">	var u User</span><br><span class="line">	jsonStr := structForJson()</span><br><span class="line">	err := json.Unmarshal([]byte(jsonStr), &amp;u)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("json for struct err:%v\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("struct is %v\n", u)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// map转json</span><br><span class="line">func mapForJson() (jsonStr string) {</span><br><span class="line">	var m map[string]interface{}</span><br><span class="line">	m = make(map[string]interface{})</span><br><span class="line">	m["username"] = "admin"</span><br><span class="line">	m["age"] = 19</span><br><span class="line">	m["sex"] = "男"</span><br><span class="line">	m["phone"] = "13770000000"</span><br><span class="line">	mj, err := json.Marshal(m)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("map for json err:%v\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	jsonStr = string(mj)</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// json转map</span><br><span class="line">func jsonForMap() {</span><br><span class="line">	var m map[string]interface{}</span><br><span class="line">	m = make(map[string]interface{})</span><br><span class="line">	jsonStr := mapForJson()</span><br><span class="line">	err := json.Unmarshal([]byte(jsonStr), &amp;m)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("json for map err:%v\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("map is %v\n", m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// slice转json</span><br><span class="line">func sliceForJson() (jsonStr string) {</span><br><span class="line">	var l []*User</span><br><span class="line">	u1 := &amp;User{</span><br><span class="line">		UserName: "u1",</span><br><span class="line">		Age:      18,</span><br><span class="line">		Sex:      "男",</span><br><span class="line">		Phone:    "110",</span><br><span class="line">	}</span><br><span class="line">	u2 := &amp;User{</span><br><span class="line">		UserName: "u2",</span><br><span class="line">		Age:      28,</span><br><span class="line">		Sex:      "男",</span><br><span class="line">		Phone:    "120",</span><br><span class="line">	}</span><br><span class="line">	l = append(l, u1)</span><br><span class="line">	l = append(l, u2)</span><br><span class="line">	lj, err := json.Marshal(l)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("slice for json err:%v\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	jsonStr = string(lj)</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// json转slice</span><br><span class="line">func jsonForSlice() {</span><br><span class="line">	var l []User</span><br><span class="line">	var u1 User</span><br><span class="line">	var u2 User</span><br><span class="line">	l = append(l, u1)</span><br><span class="line">	l = append(l, u2)</span><br><span class="line">	jsonStr := sliceForJson()</span><br><span class="line">	err := json.Unmarshal([]byte(jsonStr), &amp;l)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("json for map err:%v\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("map is %v\n", l)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	jsonForStruct()</span><br><span class="line">	jsonForMap()</span><br><span class="line">	jsonForSlice()</span><br><span class="line">}</span><br><span class="line">----------------------</span><br><span class="line">struct is {root 18 男 13160000001}</span><br><span class="line">map is map[age:19 phone:13770000000 sex:男 username:admin]</span><br><span class="line">map is [{u1 18 男 110} {u2 28 男 120}]</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的反射</title>
    <url>/2020/11/14/Golang/%E5%8F%8D%E5%B0%84/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type FooIF interface {</span><br><span class="line">    DoSomething()</span><br><span class="line">    DoSomethingWithArg(a string)</span><br><span class="line">    DoSomethingWithUnCertenArg(a ... string)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Foo struct {</span><br><span class="line">    A int</span><br><span class="line">    B string</span><br><span class="line">    C struct {</span><br><span class="line">        C1 int</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (f *Foo) DoSomething() {</span><br><span class="line">    fmt.Println(f.A, f.B)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (f *Foo) DoSomethingWithArg(a string) {</span><br><span class="line">    fmt.Println(f.A, f.B, a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (f *Foo) DoSomethingWithUnCertenArg(a ... string) {</span><br><span class="line">    fmt.Println(f.A, f.B, a[0])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (f *Foo) returnOneResult() int {</span><br><span class="line">    return 2</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var simpleObj Foo</span><br><span class="line">    var pointer2obj = &amp;simpleObj</span><br><span class="line">    var simpleIntArray = [3]int{1, 2, 3}</span><br><span class="line">    var simpleMap = map[string]string{</span><br><span class="line">        "a": "b",</span><br><span class="line">    }</span><br><span class="line">    var simpleChan = make(chan int, 1)</span><br><span class="line">    var x uint64</span><br><span class="line">    var y uint32</span><br><span class="line"></span><br><span class="line">    varType := reflect.TypeOf(simpleObj)</span><br><span class="line">    varPointerType := reflect.TypeOf(pointer2obj)</span><br><span class="line"></span><br><span class="line">    // 对齐之后要多少容量</span><br><span class="line">    fmt.Println("Align: ", varType.Align())</span><br><span class="line">    // 作为结构体的`field`要对其之后要多少容量</span><br><span class="line">    fmt.Println("FieldAlign: ", varType.FieldAlign())</span><br><span class="line">    // 叫啥</span><br><span class="line">    fmt.Println("Name: ", varType.Name())</span><br><span class="line">    // 绝对引入路径</span><br><span class="line">    fmt.Println("PkgPath: ", varType.PkgPath())</span><br><span class="line">    // 实际上用了多少内存</span><br><span class="line">    fmt.Println("Size: ", varType.Size())</span><br><span class="line">    // 到底啥类型的</span><br><span class="line">    fmt.Println("Kind: ", varType.Kind())</span><br><span class="line"></span><br><span class="line">    // 有多少函数</span><br><span class="line">    fmt.Println("NumMethod: ", varPointerType.NumMethod())</span><br><span class="line"></span><br><span class="line">    // 通过名字获取一个函数</span><br><span class="line">    m, success := varPointerType.MethodByName("DoSomethingWithArg")</span><br><span class="line">    if success {</span><br><span class="line">        m.Func.Call([]reflect.Value{</span><br><span class="line">            reflect.ValueOf(pointer2obj),</span><br><span class="line">            reflect.ValueOf("sad"),</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 通过索引获取函数</span><br><span class="line">    m = varPointerType.Method(1)</span><br><span class="line">    m.Func.Call([]reflect.Value{</span><br><span class="line">        reflect.ValueOf(pointer2obj),</span><br><span class="line">        reflect.ValueOf("sad2"),</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 是否实现了某个接口</span><br><span class="line">    fmt.Println("Implements:", varPointerType.Implements(reflect.TypeOf((*FooIF)(nil)).Elem()))</span><br><span class="line"></span><br><span class="line">    //  看看指针多少bit</span><br><span class="line">    fmt.Println("Bits: ", reflect.TypeOf(x).Bits())</span><br><span class="line"></span><br><span class="line">    // 查看array, chan, map, ptr, slice的元素类型</span><br><span class="line">    fmt.Println("Elem: ", reflect.TypeOf(simpleIntArray).Elem().Kind())</span><br><span class="line"></span><br><span class="line">    // 查看Array长度</span><br><span class="line">    fmt.Println("Len: ", reflect.TypeOf(simpleIntArray).Len())</span><br><span class="line"></span><br><span class="line">    // 查看结构体field</span><br><span class="line">    fmt.Println("Field", varType.Field(1))</span><br><span class="line"></span><br><span class="line">    // 查看结构体field</span><br><span class="line">    fmt.Println("FieldByIndex", varType.FieldByIndex([]int{2, 0}))</span><br><span class="line"></span><br><span class="line">    // 查看结构提field</span><br><span class="line">    fi, success2 := varType.FieldByName("A")</span><br><span class="line">    if success2 {</span><br><span class="line">        fmt.Println("FieldByName", fi)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 查看结构体field</span><br><span class="line">    fi, success2 = varType.FieldByNameFunc(func(fieldName string) bool {</span><br><span class="line">        return fieldName == "A"</span><br><span class="line">    })</span><br><span class="line">    if success2 {</span><br><span class="line">        fmt.Println("FieldByName", fi)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //  查看结构体数量</span><br><span class="line">    fmt.Println("NumField", varType.NumField())</span><br><span class="line"></span><br><span class="line">    // 查看map的key类型</span><br><span class="line">    fmt.Println("Key: ", reflect.TypeOf(simpleMap).Key().Name())</span><br><span class="line"></span><br><span class="line">    // 查看函数有多少个参数</span><br><span class="line">    fmt.Println("NumIn: ", reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).NumIn())</span><br><span class="line"></span><br><span class="line">    // 查看函数参数的类型</span><br><span class="line">    fmt.Println("In: ", reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).In(0))</span><br><span class="line"></span><br><span class="line">    // 查看最后一个参数，是否解构了</span><br><span class="line">    fmt.Println("IsVariadic: ", reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).IsVariadic())</span><br><span class="line"></span><br><span class="line">    // 查看函数有多少输出</span><br><span class="line">    fmt.Println("NumOut: ", reflect.TypeOf(pointer2obj.DoSomethingWithUnCertenArg).NumOut())</span><br><span class="line"></span><br><span class="line">    // 查看函数输出的类型</span><br><span class="line">    fmt.Println("Out: ", reflect.TypeOf(pointer2obj.returnOneResult).Out(0))</span><br><span class="line"></span><br><span class="line">    // 查看通道的方向, 3双向。</span><br><span class="line">    fmt.Println("ChanDir: ", int(reflect.TypeOf(simpleChan).ChanDir()))</span><br><span class="line"></span><br><span class="line">    // 查看该类型是否可以比较。不能比较的slice, map, func</span><br><span class="line">    fmt.Println("Comparable: ", varPointerType.Comparable())</span><br><span class="line"></span><br><span class="line">    // 查看类型是否可以转化成另外一种类型</span><br><span class="line">    fmt.Println("ConvertibleTo: ", varPointerType.ConvertibleTo(reflect.TypeOf("a")))</span><br><span class="line"></span><br><span class="line">    // 该类型的值是否可以另外一个类型</span><br><span class="line">    fmt.Println("AssignableTo: ", reflect.TypeOf(x).AssignableTo(reflect.TypeOf(y)))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的内置函数与递归函数</title>
    <url>/2020/11/14/Golang/%E5%9F%BA%E7%A1%80/Go%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%B8%8E%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="Go的内置函数"><a href="#Go的内置函数" class="headerlink" title="Go的内置函数"></a>Go的内置函数</h3><ul>
<li>close 主要用来关闭channle  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    // 定义一个channel 长度为10  也可以不定义长度 make(chan int)</span><br><span class="line">    ch := make(chan int, 10)</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    /*</span><br><span class="line">        有关 channel 的关闭，你需要注意以下事项:</span><br><span class="line">        关闭一个未初始化(nil) 的 channel 会产生 panic</span><br><span class="line">        重复关闭同一个 channel 会产生 panic</span><br><span class="line">        向一个已关闭的 channel 中发送消息会产生 panic</span><br><span class="line">        从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已读出，则会读到类型的零值。从一个已关闭的 channel 中读取消息永远不会阻塞，并且会返回一个为 false 的 ok-idiom，可以用它来判断 channel 是否关闭</span><br><span class="line">        关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息</span><br><span class="line">    */</span><br><span class="line">    // 关闭了channel</span><br><span class="line">    close(ch)</span><br><span class="line">    for v := range ch {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 消息被读完  这里读到0值</span><br><span class="line">    x, ok := &lt;-ch</span><br><span class="line">    fmt.Println(x, ok)</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a></li>
<li>len：用来求长度，比如：string、array、slice、map、channel</li>
<li>new：用来分配内存，主要用来分配值类型，比如：int、struct，返回的是指针</li>
<li>make：用来分配内存，主要用来分配引用类型，比如：chan、map、slice  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    // new 主要用来分配值类型 返回的是指针 如果创建slice等引用类型 并不会初始化</span><br><span class="line">    s1 := new([]int)</span><br><span class="line">    // make 用来分配引用类型</span><br><span class="line">    s2 := make([]int, 10)</span><br><span class="line"></span><br><span class="line">    s3 := new(int)</span><br><span class="line"></span><br><span class="line">    s4 := new(chan int)</span><br><span class="line"></span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">    fmt.Println(*s3)</span><br><span class="line">    fmt.Println(*s4)</span><br><span class="line">    fmt.Println("----------")</span><br><span class="line"></span><br><span class="line">    // 这里s1并没有被初始化</span><br><span class="line">    // (*s1)[0] = 1 如果不初始化  直接赋值会报错  error</span><br><span class="line">    *s1 = make([]int, 10)</span><br><span class="line">    (*s1)[0] = 1</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">    s2[0] = 1</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>append：用来追加元素到数组、slice中</li>
<li>panic和recover：用来做错误处理  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func initConfig() error {</span><br><span class="line">    // 返回一个自定义error</span><br><span class="line">    return errors.New("init config error")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">    // defer的触发时机：</span><br><span class="line">    // 1. 包裹defer的函数返回时</span><br><span class="line">    // 2. 包裹defer的函数执行到末尾时</span><br><span class="line">    // 3. 包裹defer的函数发生panic时</span><br><span class="line">    defer func() {</span><br><span class="line">        // 捕获panic</span><br><span class="line">        if err := recover(); err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    err := initConfig()</span><br><span class="line">    if err != nil {</span><br><span class="line">        panic(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3></li>
<li>阶乘  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func calc(n int) int {</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    if n == 1 {</span><br><span class="line">        return 1</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return calc(n-1) * n</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(calc(5))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
  图例:<br>  <img src="http://files.codedog.link/blog/typecho/%E9%80%92%E5%BD%92%E9%98%B6%E4%B9%98.png" alt="示例代码执行流程" title="Go递归实现阶乘"></li>
<li>斐波那契数列  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func fab(n int) int {</span><br><span class="line">    if n &lt;= 1 {</span><br><span class="line">        return 1</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return fab(n-1) + fab(n-2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    for i := 0; i &lt; 6; i++ {</span><br><span class="line">        fmt.Printf("%d,", fab(i))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的map</title>
    <url>/2020/11/14/Golang/%E5%9F%BA%E7%A1%80/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84map/</url>
    <content><![CDATA[<h3 id="map的声明"><a href="#map的声明" class="headerlink" title="map的声明"></a>map的声明</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test1() {</span><br><span class="line">	fmt.Printf("map的声明与初始化\n")</span><br><span class="line">	// map key-value的数据结构 又叫字典</span><br><span class="line">	// 1.声明</span><br><span class="line">	var m map[string]string</span><br><span class="line">	var m1 map[string]int</span><br><span class="line">	var m2 map[string]map[string]string</span><br><span class="line">	// 声明是不会分配内存的,初始化需要使用make</span><br><span class="line">	m = make(map[string]string, 5)</span><br><span class="line">	m["s1"] = "1"</span><br><span class="line"></span><br><span class="line">	m1 = make(map[string]int, 5)</span><br><span class="line">	m1["s1"] = 1</span><br><span class="line"></span><br><span class="line">	// 注意 这里m2只初始化了key value同样需要初始化 否则会panic</span><br><span class="line">	m2 = make(map[string]map[string]string, 5)</span><br><span class="line">	m2["s1"] = make(map[string]string, 5)</span><br><span class="line">	m2["s1"]["y1"] = "s1-y1-1"</span><br><span class="line">	fmt.Printf("m:%v\n", m)</span><br><span class="line">	fmt.Printf("m1:%v\n", m1)</span><br><span class="line">	fmt.Printf("m2:%v\n", m2)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test1()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">--------map的声明与初始化--------</span><br><span class="line">m:map[s1:1]</span><br><span class="line">m1:map[s1:1]</span><br><span class="line">m2:map[s1:map[y1:s1-y1-1]]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map的插入与更新"><a href="#map的插入与更新" class="headerlink" title="map的插入与更新"></a>map的插入与更新</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test2() {</span><br><span class="line">	fmt.Printf("-------map的插入和更新-------\n")</span><br><span class="line">	var m map[string]string = map[string]string{"s1": "hello world"}</span><br><span class="line">	fmt.Printf("m:%v\n", m)</span><br><span class="line">	m["s1"] = "hi"</span><br><span class="line">	fmt.Printf("update m:%v\n", m)</span><br><span class="line">	// 查找</span><br><span class="line">	if _, ok := m["s1"]; ok {</span><br><span class="line">		fmt.Printf("m[s1]:%v\n", m["s1"])</span><br><span class="line">	}</span><br><span class="line">	// 遍历map</span><br><span class="line">	for k, v := range m {</span><br><span class="line">		fmt.Printf("%s:%s\n", k, v)</span><br><span class="line">	}</span><br><span class="line">	// 删除map内的元素</span><br><span class="line">	delete(m, "s1")</span><br><span class="line">	fmt.Printf("len:%d\n", len(m))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test2()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------map的插入和更新-------</span><br><span class="line">m:map[s1:hello world]</span><br><span class="line">update m:map[s1:hi]</span><br><span class="line">m[s1]:hi</span><br><span class="line">s1:hi</span><br><span class="line">len:0</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map嵌套的初始化和遍历"><a href="#map嵌套的初始化和遍历" class="headerlink" title="map嵌套的初始化和遍历"></a>map嵌套的初始化和遍历</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func modify(m map[string]map[string]string) {</span><br><span class="line">	fmt.Printf("%p\n", m)</span><br><span class="line">	// 判断m的key对应的map是否初始化</span><br><span class="line">	if _, ok := m["s1"]; !ok {</span><br><span class="line">		fmt.Println(ok)</span><br><span class="line">		m["s1"] = make(map[string]string, 5)</span><br><span class="line">	}</span><br><span class="line">	m["s1"]["y1"] = "s1-y1-1"</span><br><span class="line">	fmt.Printf("modify:m[s1][y1]:%v\n", m["s1"]["y1"])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func trans(m map[string]map[string]string) {</span><br><span class="line">	// 遍历map嵌套</span><br><span class="line">	for k, v := range m {</span><br><span class="line">		fmt.Printf("k:%s\n", k)</span><br><span class="line">		for k1, v1 := range v {</span><br><span class="line">			fmt.Printf("%s:[%s:%v]\n", k, k1, v1)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test3() {</span><br><span class="line">	fmt.Printf("-------map嵌套的初始化-------\n")</span><br><span class="line">	// map是引用类型 在传递时传递的时地址的副本</span><br><span class="line">	m := make(map[string]map[string]string, 5)</span><br><span class="line">	fmt.Printf("%p\n", m)</span><br><span class="line">	modify(m)</span><br><span class="line">	// 这里也能读取到modify对m的初始化和赋值</span><br><span class="line">	fmt.Printf("test3:m[s1][y1]:%v\n", m["s1"]["y1"])</span><br><span class="line"></span><br><span class="line">	m["s1"]["y2"] = "s1-y2-2"</span><br><span class="line">	m["s1"]["y3"] = "s1-y3-3"</span><br><span class="line">	m["s2"] = make(map[string]string, 5)</span><br><span class="line">	m["s2"]["y1"] = "s2-y1-1"</span><br><span class="line">	m["s2"]["y2"] = "s2-y2-2"</span><br><span class="line">	m["s2"]["y3"] = "s2-y3-3"</span><br><span class="line"></span><br><span class="line">	trans(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test3()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------map嵌套的初始化-------</span><br><span class="line">0xc00006a510</span><br><span class="line">0xc00006a510</span><br><span class="line">false</span><br><span class="line">modify:m[s1][y1]:s1-y1-1</span><br><span class="line">test3:m[s1][y1]:s1-y1-1</span><br><span class="line">k:s1</span><br><span class="line">s1:[y1:s1-y1-1]</span><br><span class="line">s1:[y2:s1-y2-2]</span><br><span class="line">s1:[y3:s1-y3-3]</span><br><span class="line">k:s2</span><br><span class="line">s2:[y1:s2-y1-1]</span><br><span class="line">s2:[y2:s2-y2-2]</span><br><span class="line">s2:[y3:s2-y3-3]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="slice与map嵌套的初始化"><a href="#slice与map嵌套的初始化" class="headerlink" title="slice与map嵌套的初始化"></a>slice与map嵌套的初始化</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test4() {</span><br><span class="line">	fmt.Printf("-------slice与map嵌套的初始化-------\n")</span><br><span class="line">	a := make([]map[string]int, 5)</span><br><span class="line">	if a[0] == nil {</span><br><span class="line">		a[0] = make(map[string]int, 5)</span><br><span class="line">	}</span><br><span class="line">	a[0]["s1"] = 1</span><br><span class="line">	a[0]["s2"] = 2</span><br><span class="line">	a[0]["s3"] = 3</span><br><span class="line">	fmt.Printf("%v\n", a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test3()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------slice与map嵌套的初始化-------</span><br><span class="line">[map[s1:1 s2:2 s3:3] map[] map[] map[] map[]]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test5() {</span><br><span class="line">	fmt.Printf("---------------map排序-----------------\n")</span><br><span class="line">	// Go的map是无序的 只在fmt.print打印时候有序</span><br><span class="line">	a := make(map[string]string, 5)</span><br><span class="line"></span><br><span class="line">	a["3"] = "hij"</span><br><span class="line">	a["1"] = "abc"</span><br><span class="line">	a["2"] = "def"</span><br><span class="line">	a["4"] = "opq"</span><br><span class="line"></span><br><span class="line">	for k, v := range a {</span><br><span class="line">		fmt.Printf("%s,%s\n", k, v)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	// 把map的key取出来放入slice进行排序</span><br><span class="line">	slices := make([]string, 0, 5)</span><br><span class="line">	for k, _ := range a {</span><br><span class="line">		slices = append(slices, k)</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("排序前，key:%v\n", slices)</span><br><span class="line">	sort.Strings(slices)</span><br><span class="line">	fmt.Printf("排序后，key:%v\n", slices)</span><br><span class="line"></span><br><span class="line">	for _, v := range slices {</span><br><span class="line">		fmt.Printf("map[%s]:%s\n", v, a[v])</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test5()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------------map排序-----------------</span><br><span class="line">3,hij</span><br><span class="line">1,abc</span><br><span class="line">2,def</span><br><span class="line">4,opq</span><br><span class="line">排序前，key:[3 1 2 4]</span><br><span class="line">排序后，key:[1 2 3 4]</span><br><span class="line">map[1]:abc</span><br><span class="line">map[2]:def</span><br><span class="line">map[3]:hij</span><br><span class="line">map[4]:opq</span><br></pre></td></tr></tbody></table></figure>

<h3 id="map反转"><a href="#map反转" class="headerlink" title="map反转"></a>map反转</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test6() {</span><br><span class="line">	fmt.Printf("---------------map反转-----------------\n")</span><br><span class="line">	a := make(map[int]string, 5)</span><br><span class="line">	b := make(map[string]int, 5)</span><br><span class="line"></span><br><span class="line">	a[1] = "a"</span><br><span class="line">	a[2] = "b"</span><br><span class="line">	a[3] = "c"</span><br><span class="line">	a[4] = "d"</span><br><span class="line">	a[5] = "e"</span><br><span class="line"></span><br><span class="line">	for k, v := range a {</span><br><span class="line">		b[v] = k</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("反转后:%v\n", b)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test6()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------------map反转-----------------</span><br><span class="line">反转后:map[a:1 b:2 c:3 d:4 e:5]</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的数组与切片</title>
    <url>/2020/11/14/Golang/%E5%9F%BA%E7%A1%80/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h3 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> {</span><br><span class="line">	arr := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">	<span class="comment">// 切片是对数组的引用 因此切片是引用类型</span></span><br><span class="line">	slices := arr[<span class="number">1</span>:<span class="number">3</span>] </span><br><span class="line">	fmt.Println(slices) <span class="comment">//[2 3]</span></span><br><span class="line">	<span class="comment">// 切片的长度是指切片中元素的个数</span></span><br><span class="line">	fmt.Printf(<span class="string">"slice的长度:%d\n"</span>, <span class="built_in">len</span>(slices)) <span class="comment">//slice的长度:2</span></span><br><span class="line">	<span class="comment">// 切片的容量是指切片所指向的数组的元素到其最后一个元素的个数</span></span><br><span class="line">	fmt.Printf(<span class="string">"slice的容量:%d\n"</span>, <span class="built_in">cap</span>(slices)) <span class="comment">//slice的容量:4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> slices {</span><br><span class="line">		fmt.Println(v) <span class="comment">//2 、3</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切片的最大长度为其容量，修改切片的长度和容量一样，会显示出切片所指向数组的元素到其最后一个元素</span></span><br><span class="line">	slices = slices[:<span class="built_in">cap</span>(slices)]</span><br><span class="line">	fmt.Printf(<span class="string">"修改后:%v\n"</span>, slices) <span class="comment">// 修改后:[2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切片的地址是其所指向数组的第一个值的地址</span></span><br><span class="line">	fmt.Printf(<span class="string">"slices的地址:%p,所指向数组值的地址:%p\n"</span>, slices, &amp;arr[<span class="number">1</span>])</span><br><span class="line">        <span class="comment">//slices的地址:0xc00008e038,所指向数组值的地址:0xc00008e038</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	test1()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<h3 id="切片的内存布局"><a href="#切片的内存布局" class="headerlink" title="切片的内存布局"></a>切片的内存布局</h3><p><img src="http://files.codedog.link/blog/typecho/Go%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="切片的内存布局" title="Go切片的内存模型"></p>
<h3 id="切片的追加与拷贝"><a href="#切片的追加与拷贝" class="headerlink" title="切片的追加与拷贝"></a>切片的追加与拷贝</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test2() {</span><br><span class="line">	fmt.Printf("\n------------切片的追加与拷贝------------------\n\n")</span><br><span class="line">	slice1 := make([]int, 5, 10)</span><br><span class="line">	slice2 := []int{1, 2, 3, 4, 5}</span><br><span class="line">	fmt.Printf("slice1:%v,slice2:%v\n", slice1, slice2)</span><br><span class="line">	// 切片的追加</span><br><span class="line">	slice1 = append(slice1, slice2...)</span><br><span class="line">	fmt.Printf("slice1 append slice2:%v\n", slice1)</span><br><span class="line">	slice3 := make([]int, 10, 10)</span><br><span class="line">	// 切片的拷贝</span><br><span class="line">	copy(slice3, slice1)</span><br><span class="line">	fmt.Printf("slice3 copy slice1:%v", slice3)</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">	test2()</span><br><span class="line">}</span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">slice1:[0 0 0 0 0],slice2:[1 2 3 4 5]</span><br><span class="line">slice1 append slice2:[0 0 0 0 0 1 2 3 4 5]</span><br><span class="line">slice3 copy slice1:[0 0 0 0 0 1 2 3 4 5]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="string与slice"><a href="#string与slice" class="headerlink" title="string与slice"></a>string与slice</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test3() {</span><br><span class="line">	fmt.Printf("\n------------string与slice------------------\n\n")</span><br><span class="line">	// string的底层是一个byte的数组,因此也可以进行切片操作</span><br><span class="line">	str := "hello world"</span><br><span class="line">	slice1 := str[:]</span><br><span class="line">	fmt.Printf("slice:%v,len:%d\n", slice1, len(slice1))</span><br><span class="line">	// string本身是不可变的，因此，需要改变string中的字符，需要如下操作:</span><br><span class="line">	// slice1[0] = 'c'  错误的操作</span><br><span class="line">	str1 := []byte(str) //这里[]byte()是字节数组,如果操作中文,建议使用字符数组[]rune()</span><br><span class="line">	str1[0] = 'H'</span><br><span class="line">	str = string(str1)</span><br><span class="line">	fmt.Println(str)</span><br><span class="line"></span><br><span class="line">	str2 := "你好，世界"</span><br><span class="line">	str3 := []rune(str2)</span><br><span class="line">	str3[0] = '您'</span><br><span class="line">	str2 = string(str3)</span><br><span class="line">	fmt.Printf("处理中文:%v", str2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test3()</span><br><span class="line">}</span><br><span class="line">-----------------</span><br><span class="line">slice:hello world,len:11</span><br><span class="line">Hello world</span><br><span class="line">处理中文:您好，世界</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://files.codedog.link/blog/typecho/string%E7%9A%84%E5%BA%95%E5%B1%82%E5%B8%83%E5%B1%80.png-suofang" alt="Go中string的底层布局" title="Go中string的底层布局"></p>
<h3 id="数组的排序与二分查找"><a href="#数组的排序与二分查找" class="headerlink" title="数组的排序与二分查找"></a>数组的排序与二分查找</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test4() {</span><br><span class="line">	fmt.Printf("\n------------数组排序------------------\n\n")</span><br><span class="line">	arr := [5]int{3, 2, 1, 5, 4}</span><br><span class="line">	//数组是值类型的传递 当作参数传递时,传递的是副本 因此sort不能直接对数组进行排序,需要传入数组的slice进行排序</span><br><span class="line">	sort.Ints(arr[:])</span><br><span class="line">	fmt.Printf("排序后：%v\n", arr)</span><br><span class="line">	strarr := [5]string{"A", "a", "C", "eafa", "aEf"}</span><br><span class="line">	sort.Strings(strarr[:])</span><br><span class="line">	fmt.Printf("排序后：%v\n", strarr)</span><br><span class="line">	fmt.Printf("\n------------数组查找------------------\n\n")</span><br><span class="line">	// sort.search返回的是排序后的元素位置</span><br><span class="line">	i := sort.SearchInts(arr[:], 5)</span><br><span class="line">	fmt.Printf("数字5在数组arr中的位置下标为:%v\n", i)</span><br><span class="line">	i1 := sort.SearchStrings(strarr[:], "a")</span><br><span class="line">	fmt.Printf("字母A在数组strarr中的位置下标为:%v\n", i1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test4()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------数组排序------------------</span><br><span class="line"></span><br><span class="line">排序后：[1 2 3 4 5]</span><br><span class="line">排序后：[A C a aEf eafa]</span><br><span class="line"></span><br><span class="line">------------数组查找------------------</span><br><span class="line"></span><br><span class="line">数字5在数组arr中的位置下标为:4</span><br><span class="line">字母A在数组strarr中的位置下标为:2</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的数组</title>
    <url>/2020/11/14/Golang/%E5%9F%BA%E7%A1%80/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func arrs1() {</span><br><span class="line">	// 数组的定义与初始化</span><br><span class="line">	var arr [5]int</span><br><span class="line"></span><br><span class="line">	var arr1 [5]int = [5]int{1, 2, 3, 4, 5}</span><br><span class="line"></span><br><span class="line">	var arr2 = [5]int{1, 2, 3, 4, 5}</span><br><span class="line"></span><br><span class="line">	var arr3 = [...]int{1, 2, 3, 4, 5}</span><br><span class="line"></span><br><span class="line">	var arr4 = [...]int{0: 1, 4: 3}</span><br><span class="line"></span><br><span class="line">	arr5 := make([]int, 5)</span><br><span class="line"></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	fmt.Println(arr1)</span><br><span class="line">	fmt.Println(arr2)</span><br><span class="line">	fmt.Println(arr3)</span><br><span class="line">	fmt.Println(arr4)</span><br><span class="line">	fmt.Println(arr5)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	arrs1()</span><br><span class="line">}</span><br><span class="line">----------------------</span><br><span class="line">[0 0 0 0 0]</span><br><span class="line">[1 2 3 4 5]</span><br><span class="line">[1 2 3 4 5]</span><br><span class="line">[1 2 3 4 5]</span><br><span class="line">[1 0 0 0 3]</span><br><span class="line">[0 0 0 0 0]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<h3 id="数组的遍历方式"><a href="#数组的遍历方式" class="headerlink" title="数组的遍历方式"></a>数组的遍历方式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func arrs2() {</span><br><span class="line">	fmt.Println("遍历数组的方式:")</span><br><span class="line">	arr := [...]int{1, 2, 3, 4, 5}</span><br><span class="line">	// 遍历数组的方式1：</span><br><span class="line">	for i := 0; i &lt; len(arr); i++ {</span><br><span class="line">		fmt.Println(arr[i])</span><br><span class="line">	}</span><br><span class="line">	// 2:</span><br><span class="line">	for i, v := range arr {</span><br><span class="line">		fmt.Printf("%d:%d\n", i, v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	arrs2()</span><br><span class="line">}</span><br><span class="line">--------------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">0:1</span><br><span class="line">1:2</span><br><span class="line">2:3</span><br><span class="line">3:4</span><br><span class="line">4:5</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数组的小特性"><a href="#数组的小特性" class="headerlink" title="数组的小特性"></a>数组的小特性</h3><blockquote>
<p>数组是值类型，因此改变数组的副本的值并不会使其本身的值发生改变</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func arrs3() {</span><br><span class="line"></span><br><span class="line">	arr := [3]int{1, 2, 3}</span><br><span class="line"></span><br><span class="line">	arr1 := arr</span><br><span class="line">	// 数组是值类型  改变副本的值并不会改变本身的值</span><br><span class="line">	arr1[2] = 5</span><br><span class="line">	fmt.Printf("arr:%v\n", arr)</span><br><span class="line">	fmt.Printf("arr1:%v\n", arr1)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	arrs2()</span><br><span class="line">}</span><br><span class="line">--------------------</span><br><span class="line">arr:[1 2 3]</span><br><span class="line">arr1:[1 2 5]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用数组实现斐波那契数列"><a href="#使用数组实现斐波那契数列" class="headerlink" title="使用数组实现斐波那契数列"></a>使用数组实现斐波那契数列</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func fab() {</span><br><span class="line">	// 使用数组的方式打印斐波那契数列</span><br><span class="line">	arr := make([]int, 10)</span><br><span class="line"></span><br><span class="line">	arr[0] = 1</span><br><span class="line">	arr[1] = 1</span><br><span class="line">	for i := 2; i &lt; 10; i++ {</span><br><span class="line">		arr[i] = arr[i-1] + arr[i-2]</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("斐波那契数列:%v\n", arr)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	fab()</span><br><span class="line">}</span><br><span class="line">--------------------</span><br><span class="line">斐波那契数列:[1 1 2 3 5 8 13 21 34 55]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历二维数组"><a href="#遍历二维数组" class="headerlink" title="遍历二维数组"></a>遍历二维数组</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func arrs4() {</span><br><span class="line">	// 多维数组</span><br><span class="line">	arr := [2][3]int{{1, 2, 3}, {4, 5, 6}}</span><br><span class="line"></span><br><span class="line">	for i, v := range arr {</span><br><span class="line">		for _, v1 := range v {</span><br><span class="line">			fmt.Printf("第[%d]行:%d ", i, v1)</span><br><span class="line">		}</span><br><span class="line">		fmt.Println()</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	fab()</span><br><span class="line">}</span><br><span class="line">--------------------</span><br><span class="line">第[0]行:1 第[0]行:2 第[0]行:3</span><br><span class="line">第[1]行:4 第[1]行:5 第[1]行:6</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的闭包</title>
    <url>/2020/11/14/Golang/%E5%9F%BA%E7%A1%80/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func makeSuffixFunc(suffix string) func(string) string {</span><br><span class="line">	return func(str string) string {</span><br><span class="line">		if !strings.HasSuffix(str, suffix) {</span><br><span class="line">			return str + suffix</span><br><span class="line">		}</span><br><span class="line">		return str</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func adder() func(int) int {</span><br><span class="line">	var x int = 0</span><br><span class="line">	return func(val int) int {</span><br><span class="line">		x += val</span><br><span class="line">		return x</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	f := adder()</span><br><span class="line">	fmt.Println(f(1))</span><br><span class="line">	fmt.Println(f(100))</span><br><span class="line">	fmt.Println(f(1000))</span><br><span class="line"></span><br><span class="line">	f1 := makeSuffixFunc(".jpg")</span><br><span class="line">	fmt.Println(f1("123"))</span><br><span class="line">	f2 := makeSuffixFunc(".txt")</span><br><span class="line">	fmt.Println(f2("hello"))</span><br><span class="line">}</span><br><span class="line">-----------------------------------print:</span><br><span class="line">1</span><br><span class="line">101</span><br><span class="line">1101</span><br><span class="line">123.jpg</span><br><span class="line">hello.txt</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>闭包可以读取函数内部的变量，并且会让这个变量始终保存在内存中</li>
</ul>
<blockquote>
<p>使用闭包的注意点</p>
</blockquote>
<ul>
<li>由于闭包会使函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则可能会造成性能问题，还可能会导致内存泄漏</li>
<li>不要随便修改父函数中的内部变量！！！！！</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的多线程</title>
    <url>/2020/11/14/Golang/%E5%B9%B6%E5%8F%91/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="goroute详解"><a href="#goroute详解" class="headerlink" title="goroute详解"></a>goroute详解</h3><ul>
<li>获取和设置当前runtime可用的最大核心数:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	// 返回当前主机的cpu核心数</span><br><span class="line">	num := runtime.NumCPU()</span><br><span class="line">	// 设置当前runtime可用的最大核心数</span><br><span class="line">	runtime.GOMAXPROCS(num)</span><br><span class="line">	fmt.Printf("max cup :%v\n", num)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 多线程 编译时建议带上参数-race,可以帮助检测函数中是否有锁竞争  go build -race xx/xxx/xxx/main</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	m    = make(map[int]int)</span><br><span class="line">	lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func calc(c int) {</span><br><span class="line">	num := 1</span><br><span class="line">	for i := 1; i &lt; c; i++ {</span><br><span class="line">		num *= i</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	lock.Lock()</span><br><span class="line">	m[c] = num</span><br><span class="line">	lock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	for i := 0; i &lt; 10; i++ {</span><br><span class="line">		go calc(i)</span><br><span class="line">	}</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	lock.Lock()</span><br><span class="line">	for k, v := range m {</span><br><span class="line">		fmt.Printf("k:%v,v:%v\n", k, v)</span><br><span class="line">	}</span><br><span class="line">	lock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="channel的使用"><a href="#channel的使用" class="headerlink" title="channel的使用:"></a>channel的使用:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 如果存放的元素超过了channel定义的长度，则会处于阻塞状态,直到channel内的元素被取出</span><br><span class="line"></span><br><span class="line">func test1() {</span><br><span class="line">	var m chan int</span><br><span class="line">	m = make(chan int, 10)</span><br><span class="line">	m &lt;- 1</span><br><span class="line">	m &lt;- 2</span><br><span class="line">	m &lt;- 3</span><br><span class="line"></span><br><span class="line">	a := &lt;-m</span><br><span class="line">	fmt.Printf("a:%d\n", a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test2() {</span><br><span class="line">	var c chan map[string]string</span><br><span class="line">	c = make(chan map[string]string, 10)</span><br><span class="line">	m := make(map[string]string, 10)</span><br><span class="line">	m["m1"] = "01"</span><br><span class="line">	m["m2"] = "02"</span><br><span class="line"></span><br><span class="line">	c &lt;- m</span><br><span class="line"></span><br><span class="line">	v := &lt;-c</span><br><span class="line">	fmt.Printf("v:%v\n", v)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test3() {</span><br><span class="line">	var c chan student</span><br><span class="line">	c = make(chan student, 10)</span><br><span class="line">	s := student{</span><br><span class="line">		name: "张三",</span><br><span class="line">	}</span><br><span class="line">	c &lt;- s</span><br><span class="line"></span><br><span class="line">	v := &lt;-c</span><br><span class="line">	fmt.Printf("v:%v\n", v)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test1()</span><br><span class="line">	test2()</span><br><span class="line">	test3()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="在gorutine中使用channel"><a href="#在gorutine中使用channel" class="headerlink" title="在gorutine中使用channel:"></a>在gorutine中使用channel:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func write(c chan int) {</span><br><span class="line">	// 如果存放的元素超过了channel定义的长度，则会处于阻塞状态,直到channel内的元素被取出</span><br><span class="line">	for i := 0; i &lt; 100; i++ {</span><br><span class="line">		c &lt;- i</span><br><span class="line">		fmt.Println("put data:", i)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func read(c chan int) {</span><br><span class="line">	for {</span><br><span class="line">		var b int</span><br><span class="line">		b = &lt;-c</span><br><span class="line">		fmt.Println("pop data:", b)</span><br><span class="line">		time.Sleep(time.Millisecond * 100)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var c chan int</span><br><span class="line">	c = make(chan int, 10)</span><br><span class="line">	go write(c)</span><br><span class="line">	go read(c)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * 10)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="多个goroutine并发"><a href="#多个goroutine并发" class="headerlink" title="多个goroutine并发:"></a>多个goroutine并发:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func initData(c chan int) {</span><br><span class="line">	for i := 0; i &lt; 10000; i++ {</span><br><span class="line">		c &lt;- i</span><br><span class="line">	}</span><br><span class="line">	close(c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func calc(takeChan chan int, result chan int, exit chan bool) {</span><br><span class="line">	flag := true</span><br><span class="line">	for v := range takeChan {</span><br><span class="line"></span><br><span class="line">		for i := 2; i &lt; v; i++ {</span><br><span class="line">			if v%i == 0 {</span><br><span class="line">				flag = false</span><br><span class="line">				break</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		if flag {</span><br><span class="line">			result &lt;- v</span><br><span class="line">		}</span><br><span class="line">		flag = true</span><br><span class="line">	}</span><br><span class="line">	exit &lt;- true</span><br><span class="line">	fmt.Println("exit-----------------------------------------------------")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func read(result chan int) {</span><br><span class="line">	for v := range result {</span><br><span class="line">		fmt.Println("result:", v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var intChan chan int</span><br><span class="line">	var resultChan chan int</span><br><span class="line">	var exitChan chan bool</span><br><span class="line">	intChan = make(chan int, 1000)</span><br><span class="line">	resultChan = make(chan int, 1000)</span><br><span class="line">	exitChan = make(chan bool, runtime.NumCPU())</span><br><span class="line">	go initData(intChan)</span><br><span class="line">	for i := 0; i &lt; runtime.NumCPU(); i++ {</span><br><span class="line">		go calc(intChan, resultChan, exitChan)</span><br><span class="line">		go read(resultChan)</span><br><span class="line">	}</span><br><span class="line">	for i := 0; i &lt; runtime.NumCPU(); i++ {</span><br><span class="line">		fmt.Printf("**************************wait goroute:%d************************\n", i)</span><br><span class="line">		&lt;-exitChan</span><br><span class="line">	}</span><br><span class="line">	close(resultChan)</span><br><span class="line">	close(exitChan)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="channel使用完要关闭："><a href="#channel使用完要关闭：" class="headerlink" title="channel使用完要关闭："></a>channel使用完要关闭：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	var c chan int</span><br><span class="line">	c = make(chan int, 10)</span><br><span class="line">	for i := 0; i &lt; 10; i++ {</span><br><span class="line">		c &lt;- i</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	close(c)</span><br><span class="line">	for {</span><br><span class="line">		v, ok := &lt;-c</span><br><span class="line">		if ok == false {</span><br><span class="line">			fmt.Println("channel is colse!")</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### select关键字的使用:</span><br></pre></td></tr></tbody></table></figure>
<p>func main() {<br>    var ch chan int<br>    var ch2 chan int<br>    ch = make(chan int, 10)<br>    ch2 = make(chan int, 10)<br>    go func() {<br>        for i := 0; i &lt; 10; i++ {<br>            ch &lt;- i<br>            ch2 &lt;- i * i<br>            time.Sleep(time.Second)<br>        }<br>    }()</p>
<pre><code>for {
    select {
    case v := &lt;-ch:
        fmt.Println(v)
    case v := &lt;-ch2:
        fmt.Println(v)
    default:
        fmt.Println("get data timeout")
        time.Sleep(time.Second)
    }
}</code></pre>
<p>}</p>
<p>```</p>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的线程同步-锁机制</title>
    <url>/2020/11/14/Golang/%E5%B9%B6%E5%8F%91/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><blockquote>
<p>若不加互斥锁,下面这段程序中map[1]的数值可能为负数(多次执行结果可能不相同,但大多都为负数)</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var lock sync.Mutex</span><br><span class="line"></span><br><span class="line">func consumer(m map[int]int) {</span><br><span class="line">	// 定义一个消费者,用来消费传入的map中的数值，直到数值小于或等于0</span><br><span class="line">	// 在没有使用互斥锁时,map中的数值可能会出现负数</span><br><span class="line">	// 读写锁适合在读写频率相差不多的情况下使用,其会影响性能</span><br><span class="line">	for i := 0; i &lt; 100; i++ {</span><br><span class="line">		go func(m1 map[int]int) {</span><br><span class="line">			lock.Lock() //上锁</span><br><span class="line">			if m1[1] &gt; 0 {</span><br><span class="line">				time.Sleep(time.Microsecond)</span><br><span class="line">				m1[1] = m1[1] - 1</span><br><span class="line">			}</span><br><span class="line">			lock.Unlock() //解锁</span><br><span class="line">		}(m)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test1() {</span><br><span class="line">	m := make(map[int]int, 1)</span><br><span class="line">	m[1] = 10</span><br><span class="line">	consumer(m)</span><br><span class="line">	time.Sleep(3 * time.Second)</span><br><span class="line">	fmt.Printf("map:%v", m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test1()</span><br><span class="line">}</span><br><span class="line">---------------------</span><br><span class="line">map:map[1:0]</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><blockquote>
<p>下面这段程序可以看出:在读锁时,两个读操作可以并发执行, 而在写锁时,只有一个写锁释放了，另一个写锁才会执行</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var rwlock sync.RWMutex</span><br><span class="line"></span><br><span class="line">func read(i int) {</span><br><span class="line">	fmt.Println(i, "read start")</span><br><span class="line">	rwlock.RLock()</span><br><span class="line">	start := 0</span><br><span class="line">	pr := "read"</span><br><span class="line"></span><br><span class="line">	for {</span><br><span class="line">		if start &gt; 10 {</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line">		time.Sleep(time.Millisecond)</span><br><span class="line">		pr += "."</span><br><span class="line">		fmt.Println(i, pr)</span><br><span class="line">		start++</span><br><span class="line">	}</span><br><span class="line">	rwlock.RUnlock()</span><br><span class="line">	fmt.Println(i, "read end")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func write(i int) {</span><br><span class="line">	fmt.Println(i, "write start")</span><br><span class="line">	rwlock.Lock()</span><br><span class="line">	start := 0</span><br><span class="line">	pr := "write"</span><br><span class="line"></span><br><span class="line">	for {</span><br><span class="line">		if start &gt; 10 {</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line">		time.Sleep(time.Millisecond)</span><br><span class="line">		pr += "."</span><br><span class="line">		fmt.Println(i, pr)</span><br><span class="line">		start++</span><br><span class="line">	}</span><br><span class="line">	rwlock.Unlock()</span><br><span class="line">	fmt.Println(i, "write end")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test2() {</span><br><span class="line">	// 读写锁,适合用在读多写少的情况下</span><br><span class="line">	// 进行读操作的时候无需等待读锁的结束</span><br><span class="line">	go read(1)</span><br><span class="line">	go write(1)</span><br><span class="line">	go read(2)</span><br><span class="line">	go write(2)</span><br><span class="line">	time.Sleep(time.Second * 5)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test2()</span><br><span class="line">}</span><br><span class="line">--------------------------</span><br><span class="line">1 read start</span><br><span class="line">2 read start</span><br><span class="line">1 write start</span><br><span class="line">2 write start</span><br><span class="line">1 read.</span><br><span class="line">2 read.</span><br><span class="line">1 read..</span><br><span class="line">2 read..</span><br><span class="line">1 read...</span><br><span class="line">1 read....</span><br><span class="line">2 read...</span><br><span class="line">2 read....</span><br><span class="line">1 read.....</span><br><span class="line">2 read.....</span><br><span class="line">1 read......</span><br><span class="line">1 read.......</span><br><span class="line">2 read......</span><br><span class="line">1 read........</span><br><span class="line">2 read.......</span><br><span class="line">1 read.........</span><br><span class="line">2 read........</span><br><span class="line">2 read.........</span><br><span class="line">1 read..........</span><br><span class="line">2 read..........</span><br><span class="line">1 read...........</span><br><span class="line">1 read end</span><br><span class="line">2 read...........</span><br><span class="line">2 read end</span><br><span class="line">1 write.</span><br><span class="line">1 write..</span><br><span class="line">1 write...</span><br><span class="line">1 write....</span><br><span class="line">1 write.....</span><br><span class="line">1 write......</span><br><span class="line">1 write.......</span><br><span class="line">1 write........</span><br><span class="line">1 write.........</span><br><span class="line">1 write..........</span><br><span class="line">1 write...........</span><br><span class="line">1 write end</span><br><span class="line">2 write.</span><br><span class="line">2 write..</span><br><span class="line">2 write...</span><br><span class="line">2 write....</span><br><span class="line">2 write.....</span><br><span class="line">2 write......</span><br><span class="line">2 write.......</span><br><span class="line">2 write........</span><br><span class="line">2 write.........</span><br><span class="line">2 write..........</span><br><span class="line">2 write...........</span><br><span class="line">2 write end</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的定时器</title>
    <url>/2020/11/14/Golang/%E5%B9%B6%E5%8F%91/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h3 id="定时器的创建和初始化"><a href="#定时器的创建和初始化" class="headerlink" title="定时器的创建和初始化:"></a>定时器的创建和初始化:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 定时器</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	t := time.NewTicker(time.Second)</span><br><span class="line">	for v := range t.C {</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="一次性定时器-time-After-和-time-NewTicker-的区别-："><a href="#一次性定时器-time-After-和-time-NewTicker-的区别-：" class="headerlink" title="一次性定时器(time.After() 和 time.NewTicker()的区别)："></a>一次性定时器(time.After() 和 time.NewTicker()的区别)：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 一次性定时器</span><br><span class="line">func test1() {</span><br><span class="line">	var ch chan int</span><br><span class="line">	var ch1 chan int</span><br><span class="line">	ch = make(chan int, 10)</span><br><span class="line">	ch1 = make(chan int, 10)</span><br><span class="line">	go func() {</span><br><span class="line">		for i := 0; i &lt; 10; i++ {</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			ch1 &lt;- i * i</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	for {</span><br><span class="line">		select {</span><br><span class="line">		case v := &lt;-ch:</span><br><span class="line">			fmt.Printf("ch:%d\n", v)</span><br><span class="line">		case v := &lt;-ch1:</span><br><span class="line">			fmt.Printf("ch1:%d\n", v)</span><br><span class="line">			// 设置超时时间为1秒 不建议使用After 容易造成内存泄漏</span><br><span class="line">		case t := &lt;-time.After(time.Second):</span><br><span class="line">			fmt.Println("get data time out:", t)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test2() {</span><br><span class="line">	var ch chan int</span><br><span class="line">	var ch1 chan int</span><br><span class="line">	ch = make(chan int, 10)</span><br><span class="line">	ch1 = make(chan int, 10)</span><br><span class="line">	go func() {</span><br><span class="line">		for i := 0; i &lt; 10; i++ {</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			ch1 &lt;- i * i</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	for {</span><br><span class="line">		t := time.NewTicker(time.Second)</span><br><span class="line">		select {</span><br><span class="line">		case v := &lt;-ch:</span><br><span class="line">			fmt.Printf("ch:%d\n", v)</span><br><span class="line">		case v := &lt;-ch1:</span><br><span class="line">			fmt.Printf("ch1:%d\n", v)</span><br><span class="line">			// 设置超时时间为1秒 推荐使用</span><br><span class="line">		case t := &lt;-t.C:</span><br><span class="line">			fmt.Println("get data time out:", t)</span><br><span class="line">		}</span><br><span class="line">		// 使用完手动关闭</span><br><span class="line">		t.Stop()</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test2()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的异常处理</title>
    <url>/2020/11/14/Golang/%E5%B9%B6%E5%8F%91/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// goroutine异常处理</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line"></span><br><span class="line">	// 建议在写每个goroutine的时候  首先写处理panic的方法</span><br><span class="line">	defer func() {</span><br><span class="line">		if err := recover(); err != nil {</span><br><span class="line">			fmt.Println("panic:", err)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	// 这里map没有初始化 会发生panic 如果不捕获会导致整个进程退出</span><br><span class="line">	var m map[string]string</span><br><span class="line">	m["str"] = "s"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func calc() {</span><br><span class="line">	for {</span><br><span class="line">		fmt.Println("calc.....")</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	go test()</span><br><span class="line">	for i := 0; i &lt; 2; i++ {</span><br><span class="line">		go calc()</span><br><span class="line">	}</span><br><span class="line">	time.Sleep(time.Second * 10)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中接口的简单应用示例</title>
    <url>/2020/11/14/Golang/%E6%8E%A5%E5%8F%A3/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="实现sort-Interface接口"><a href="#实现sort-Interface接口" class="headerlink" title="实现sort.Interface接口"></a>实现sort.Interface接口</h3><blockquote>
<p>任何实现了 sort.Interface 的类型（一般为集合），均可使用该包中的方法进行排序。 这些方法要求集合内列出元素的索引为整数。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Student struct {</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type StudentArray []Student</span><br><span class="line"></span><br><span class="line">// Len 为集合内元素的总数</span><br><span class="line">func (this StudentArray) Len() int {</span><br><span class="line">	return len(this)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Less 返回索引为 i 的元素是否应排在索引为 j 的元素之前。</span><br><span class="line">func (this StudentArray) Less(i, j int) bool {</span><br><span class="line">	return this[i].Age &lt; this[j].Age</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Swap 交换索引为 i 和 j 的元素</span><br><span class="line">func (this StudentArray) Swap(i, j int) {</span><br><span class="line">	this[i], this[j] = this[j], this[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var stuArr StudentArray</span><br><span class="line">	for i := 0; i &lt; 15; i++ {</span><br><span class="line">		stu := Student{</span><br><span class="line">			Name: fmt.Sprintf("stu%d", rand.Intn(100)),</span><br><span class="line">			Age:  rand.Intn(100),</span><br><span class="line">		}</span><br><span class="line">		stuArr = append(stuArr, stu)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println("排序前：")</span><br><span class="line">	for _, v := range stuArr {</span><br><span class="line">		fmt.Printf("name:%v,age:%d\n", v.Name, v.Age)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	sort.Sort(stuArr)</span><br><span class="line">	fmt.Println("排序后：")</span><br><span class="line">	for _, v := range stuArr {</span><br><span class="line">		fmt.Printf("name:%v,age:%d\n", v.Name, v.Age)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">------------------------</span><br><span class="line">排序前：</span><br><span class="line">name:stu81,age:87</span><br><span class="line">name:stu47,age:59</span><br><span class="line">name:stu81,age:18</span><br><span class="line">name:stu25,age:40</span><br><span class="line">name:stu56,age:0</span><br><span class="line">name:stu94,age:11</span><br><span class="line">name:stu62,age:89</span><br><span class="line">name:stu28,age:74</span><br><span class="line">name:stu11,age:45</span><br><span class="line">name:stu37,age:6</span><br><span class="line">name:stu95,age:66</span><br><span class="line">name:stu28,age:58</span><br><span class="line">name:stu47,age:47</span><br><span class="line">name:stu87,age:88</span><br><span class="line">name:stu90,age:15</span><br><span class="line">排序后：</span><br><span class="line">name:stu56,age:0</span><br><span class="line">name:stu37,age:6</span><br><span class="line">name:stu94,age:11</span><br><span class="line">name:stu90,age:15</span><br><span class="line">name:stu81,age:18</span><br><span class="line">name:stu25,age:40</span><br><span class="line">name:stu11,age:45</span><br><span class="line">name:stu47,age:47</span><br><span class="line">name:stu28,age:58</span><br><span class="line">name:stu47,age:59</span><br><span class="line">name:stu95,age:66</span><br><span class="line">name:stu28,age:74</span><br><span class="line">name:stu81,age:87</span><br><span class="line">name:stu87,age:88</span><br><span class="line">name:stu62,age:89</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的类型断言</title>
    <url>/2020/11/14/Golang/%E6%8E%A5%E5%8F%A3/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><blockquote>
<p>类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型<br>可以采用以下方法进行转换：</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test1() {</span><br><span class="line">	var a interface{}</span><br><span class="line">	var b int = 10</span><br><span class="line">	a = b</span><br><span class="line">	fmt.Printf("a type is %T value is %d\n", a, a)</span><br><span class="line">	// 断言</span><br><span class="line">	c, ok := a.(int)</span><br><span class="line">	if ok == false {</span><br><span class="line">		fmt.Println("conversion fail")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("c type is %T value is %d\n", c, c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test1()</span><br><span class="line">}</span><br><span class="line">------------</span><br><span class="line">a type is int value is 10</span><br><span class="line">c type is int value is 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Student struct{}</span><br><span class="line"></span><br><span class="line">func assertion(item ...interface{}) {</span><br><span class="line">	for i, v := range item {</span><br><span class="line">		switch v.(type) {</span><br><span class="line">		case bool:</span><br><span class="line">			fmt.Printf("%d param is bool value is %v\n", i, v)</span><br><span class="line">		case string:</span><br><span class="line">			fmt.Printf("%d param is string value is %v\n", i, v)</span><br><span class="line">		case float32, float64:</span><br><span class="line">			fmt.Printf("%d param is float value is %v\n", i, v)</span><br><span class="line">		case int, int32, int64:</span><br><span class="line">			fmt.Printf("%d param is int value is %v\n", i, v)</span><br><span class="line">		case Student:</span><br><span class="line">			fmt.Printf("%d param is Student value is %v\n", i, v)</span><br><span class="line">		case *Student:</span><br><span class="line">			fmt.Printf("%d param is Student Pointer value is %v\n", i, v)</span><br><span class="line">		default:</span><br><span class="line">			fmt.Printf("%d param type is unknown value is %v\n", i, v)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test2() {</span><br><span class="line">	var stu Student</span><br><span class="line">	assertion(true, stu, 1, 1.2, "test", &amp;Student{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test2()</span><br><span class="line">}</span><br><span class="line">--------------</span><br><span class="line">0 param is bool value is true</span><br><span class="line">1 param is Student value is {}</span><br><span class="line">2 param is int value is 1</span><br><span class="line">3 param is float value is 1.2</span><br><span class="line">4 param is string value is test</span><br><span class="line">5 param is Student Pointer value is &amp;{}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的接口</title>
    <url>/2020/11/14/Golang/%E6%8E%A5%E5%8F%A3/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote>
<p>Interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。</p>
</blockquote>
<blockquote>
<p>如果一个变量实现了String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出。(对比java中的重写toString()方法)</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type student struct {</span><br><span class="line">	name string</span><br><span class="line">	age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s student) String() string {</span><br><span class="line">	str := fmt.Sprintf("name:[%s],age:[%d]\n", s.name, s.age)</span><br><span class="line">	return str</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var s student = student{</span><br><span class="line">		name: "张三",</span><br><span class="line">		age:  18,</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><blockquote>
<p> Golang中的接口，不需要显示的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。因此，golang中没有implement类似的关键字<br>如果一个变量含有了多个interface类型的方法，那么这个变量就实现了多个接口。<br> 如果一个变量只含有了1个interface的方部分方法，那么这个变量没有实现这个接口。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Person interface {</span><br><span class="line">	eat()</span><br><span class="line">	sleep()</span><br><span class="line">	run()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//  Student实现了Person接口中的所有方法即Student实现了Person接口</span><br><span class="line">type Student struct {</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) eat() {</span><br><span class="line">	fmt.Printf("%s eat!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) sleep() {</span><br><span class="line">	fmt.Printf("%s sleep!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) run() {</span><br><span class="line">	fmt.Printf("%s run!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var s Student = Student{</span><br><span class="line">		Name: "张三",</span><br><span class="line">		Age:  18,</span><br><span class="line">	}</span><br><span class="line">	s.eat()</span><br><span class="line">	s.sleep()</span><br><span class="line">	s.run()</span><br><span class="line">}</span><br><span class="line">-----------------------</span><br><span class="line">张三 eat!</span><br><span class="line">张三 sleep!</span><br><span class="line">张三 run!</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Person interface {</span><br><span class="line">	eat()</span><br><span class="line">	sleep()</span><br><span class="line">	run()</span><br><span class="line">}</span><br><span class="line">type Students interface {</span><br><span class="line">	Person</span><br><span class="line">	learn()</span><br><span class="line">	exam()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Student struct {</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) eat() {</span><br><span class="line">	fmt.Printf("%s 吃饭!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) sleep() {</span><br><span class="line">	fmt.Printf("%s 睡觉!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) run() {</span><br><span class="line">	fmt.Printf("%s 运动!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) learn() {</span><br><span class="line">	fmt.Printf("%s 学习!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) exam() {</span><br><span class="line">	fmt.Printf("%s 考试!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var s Student = Student{</span><br><span class="line">		Name: "张三",</span><br><span class="line">		Age:  18,</span><br><span class="line">	}</span><br><span class="line">	s.eat()</span><br><span class="line">	s.sleep()</span><br><span class="line">	s.run()</span><br><span class="line">	s.learn()</span><br><span class="line">	s.exam()</span><br><span class="line">}</span><br><span class="line">----------------</span><br><span class="line">张三 吃饭!</span><br><span class="line">张三 睡觉!</span><br><span class="line">张三 运动!</span><br><span class="line">张三 学习!</span><br><span class="line">张三 考试!</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote>
<p>一种事物的多种形态，都可以按照统一的接口进行操作</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Persons interface {</span><br><span class="line">	eat()</span><br><span class="line">	sleep()</span><br><span class="line">	run()</span><br><span class="line">}</span><br><span class="line">type Students interface {</span><br><span class="line">	Persons</span><br><span class="line">	learn()</span><br><span class="line">	exam()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Person struct {</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Student struct {</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) eat() {</span><br><span class="line">	fmt.Printf("%s 吃饭!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) sleep() {</span><br><span class="line">	fmt.Printf("%s 睡觉!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) run() {</span><br><span class="line">	fmt.Printf("%s 运动!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) learn() {</span><br><span class="line">	fmt.Printf("%s 学习!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s Student) exam() {</span><br><span class="line">	fmt.Printf("%s 考试!\n", s.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p Person) eat() {</span><br><span class="line">	fmt.Printf("%s 吃饭!\n", p.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p Person) sleep() {</span><br><span class="line">	fmt.Printf("%s 睡觉!\n", p.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p Person) run() {</span><br><span class="line">	fmt.Printf("%s 运动!\n", p.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var ps Persons</span><br><span class="line">	var s Student = Student{</span><br><span class="line">		Name: "张三",</span><br><span class="line">		Age:  18,</span><br><span class="line">	}</span><br><span class="line">	var p Person = Person{</span><br><span class="line">		Name: "李四",</span><br><span class="line">		Age:  18,</span><br><span class="line">	}</span><br><span class="line">	// 这里接口Persons可以是Person  也可以是Student </span><br><span class="line">	ps = s</span><br><span class="line">	ps.eat()</span><br><span class="line">	ps.run()</span><br><span class="line">	ps.sleep()</span><br><span class="line"></span><br><span class="line">	ps = p</span><br><span class="line">	ps.eat()</span><br><span class="line">	ps.run()</span><br><span class="line">	ps.sleep()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">--------------------</span><br><span class="line">张三 吃饭!</span><br><span class="line">张三 运动!</span><br><span class="line">张三 睡觉!</span><br><span class="line">李四 吃饭!</span><br><span class="line">李四 运动!</span><br><span class="line">李四 睡觉!</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现负载均衡</title>
    <url>/2020/11/14/Golang/%E7%A4%BA%E4%BE%8B/Go%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<blockquote>
<p>仅仅是对Go语言接口的练习，并无实际业务代码！</p>
</blockquote>
<ul>
<li><p>balance.go 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package balance</span><br><span class="line"></span><br><span class="line">type Balance interface {</span><br><span class="line">	DoBalance([]*Instance) (*Instance, error)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>instance.go 模拟服务器实例</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package balance</span><br><span class="line"></span><br><span class="line">import "strconv"</span><br><span class="line"></span><br><span class="line">type Instance struct {</span><br><span class="line">	host string</span><br><span class="line">	port int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewInstance(host string, port int) *Instance {</span><br><span class="line">	return &amp;Instance{</span><br><span class="line">		host: host,</span><br><span class="line">		port: port,</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (this *Instance) GetHost() string {</span><br><span class="line">	return this.host</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (this *Instance) GetPort() int {</span><br><span class="line">	return this.port</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (this *Instance) String() string {</span><br><span class="line">	return this.host + ":" + strconv.Itoa(this.port)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>random.go 模拟负载均衡，随机算法实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package balance</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"errors"</span><br><span class="line">	"math/rand"</span><br><span class="line">	"time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type RandomBalance struct{}</span><br><span class="line"></span><br><span class="line">// init方法 包被引用时调用</span><br><span class="line">func init() {</span><br><span class="line">	RegisterBalance("random", &amp;RandomBalance{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (this *RandomBalance) DoBalance(insts []*Instance) (inst *Instance, err error) {</span><br><span class="line">	lens := len(insts)</span><br><span class="line">	if lens == 0 {</span><br><span class="line">		err = errors.New("Instance is nil")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	index := rand.Intn(lens)</span><br><span class="line">	inst = insts[index]</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>roundrobin.go 模拟负载均衡，轮训算法实现</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package balance</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"errors"</span><br><span class="line">	"fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// init方法 包被引用时调用</span><br><span class="line">func init() {</span><br><span class="line">	RegisterBalance("roundrobin", &amp;RoundRobinBalance{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type RoundRobinBalance struct {</span><br><span class="line">	index int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (this *RoundRobinBalance) DoBalance(insts []*Instance) (inst *Instance, err error) {</span><br><span class="line">	lens := len(insts)</span><br><span class="line">	if lens == 0 {</span><br><span class="line">		err = errors.New("Instance is nil")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	if this.index &gt;= lens {</span><br><span class="line">		this.index = 0</span><br><span class="line">		fmt.Println("一次轮训")</span><br><span class="line">	}</span><br><span class="line">	inst = insts[this.index]</span><br><span class="line">	this.index += 1</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>mgr.go 对Balance接口实现的管理和注册</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package balance</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明一个BalanceMgr类型的变量，用来对外暴露注册</span><br><span class="line">var (</span><br><span class="line">	mgr = BalanceMgr{</span><br><span class="line">		// 这里要注意初始化BalanceMgr结构体的map</span><br><span class="line">		allBalancer: make(map[string]Balance),</span><br><span class="line">	}</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type BalanceMgr struct {</span><br><span class="line">	allBalancer map[string]Balance</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 注册实现Balance接口的结构体</span><br><span class="line">func (this *BalanceMgr) registerBalance(name string, b Balance) {</span><br><span class="line">	this.allBalancer[name] = b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func RegisterBalance(name string, b Balance) {</span><br><span class="line">	mgr.registerBalance(name, b)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 调用对应name的Balance实现类，处理传入的实例slice</span><br><span class="line">func DoBalance(name string, insts []*Instance) (inst *Instance, err error) {</span><br><span class="line">	b, ok := mgr.allBalancer[name]</span><br><span class="line">	if !ok {</span><br><span class="line">		err = fmt.Errorf("Not Fuond %s Balance", name)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	inst, err = b.DoBalance(insts)</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>hash.go 模拟负载均衡，一致性hash，对Balance接口的实现 (golang hash值的获取方法)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"go_dev/day6/example7/balance"</span><br><span class="line">	"hash/crc32"</span><br><span class="line">	"math/rand"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	balance.RegisterBalance("hash", &amp;HashBalance{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type HashBalance struct{}</span><br><span class="line"></span><br><span class="line">func (this *HashBalance) DoBalance(insts []*balance.Instance) (inst *balance.Instance, err error) {</span><br><span class="line">	defKey := fmt.Sprintf("%d", rand.Int())</span><br><span class="line">	lens := len(insts)</span><br><span class="line">	if lens == 0 {</span><br><span class="line">		err = fmt.Errorf("not backed instance")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 计算hash值</span><br><span class="line">	crcTable := crc32.MakeTable(crc32.IEEE)</span><br><span class="line">	hashVal := crc32.Checksum([]byte(defKey), crcTable)</span><br><span class="line">	// 这里hashVal是uint32的类型  需要转成int进行取余</span><br><span class="line">	index := int(hashVal) % lens</span><br><span class="line">	inst = insts[index]</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>main.go 模拟收到请求后，进行请求的分发</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"go_dev/day6/example7/balance"</span><br><span class="line">	"math/rand"</span><br><span class="line">	"os"</span><br><span class="line">	"time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var insts []*balance.Instance</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	// 创建一组机器实例</span><br><span class="line">	for i := 0; i &lt; 10; i++ {</span><br><span class="line">		host := fmt.Sprintf("192.168.%d.%d", rand.Intn(255), rand.Intn(254)+1)</span><br><span class="line">		port := 8888</span><br><span class="line">		one := balance.NewInstance(host, port)</span><br><span class="line">		insts = append(insts, one)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	balanceName := "random"</span><br><span class="line">	// 从控制台获取输入参数</span><br><span class="line">	if len(os.Args) &gt; 1 {</span><br><span class="line">		balanceName = os.Args[1]</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fmt.Printf("use %s balance\n", balanceName)</span><br><span class="line"></span><br><span class="line">	// 模拟负载均衡</span><br><span class="line">	for {</span><br><span class="line">		inst, err := balance.DoBalance(balanceName, insts)</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Printf("do balance err:%s\n", err)</span><br><span class="line">			continue</span><br><span class="line">		}</span><br><span class="line">		fmt.Printf("%v\n", inst)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>文章中并无实际业务代码，仅是对golang接口的练习，和对负载均衡的简单模拟</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>示例</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go连接Mysql</title>
    <url>/2020/11/14/Golang/%E7%A4%BA%E4%BE%8B/Go%E8%BF%9E%E6%8E%A5Mysql/</url>
    <content><![CDATA[<h3 id="1-database-sql标准包"><a href="#1-database-sql标准包" class="headerlink" title="1.database/sql标准包"></a>1.database/sql标准包</h3><blockquote>
<p>sql包提供了保证SQL或类SQL数据库的泛用接口。使用sql包时必须注入（至少）一个数据库驱动。参见<code>http://golang.org/s/sqldrivers</code> 获取驱动列表。如使用mysql，则需要注入<code>github.com/go-sql-driver/mysql。</code></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"database/sql"</span><br><span class="line">	"fmt"</span><br><span class="line">	"os"</span><br><span class="line">	"strconv"</span><br><span class="line"></span><br><span class="line">	_ "github.com/go-sql-driver/mysql"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Person pojo</span><br><span class="line">type Person struct {</span><br><span class="line">	UserID   int    `db:"user_id"`</span><br><span class="line">	UserName string `db:"username"`</span><br><span class="line">	Sex      string `db:"sex"`</span><br><span class="line">	Email    string `db:"email"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *Person) String() string {</span><br><span class="line">	return strconv.Itoa(p.UserID) + p.UserName + p.Sex + p.Email</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// ErrHandle 错误处理</span><br><span class="line">func ErrHandle(err error, where string) {</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("[ERR]:", err, where)</span><br><span class="line">		os.Exit(0)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	db, err := sql.Open("mysql", "root:toor@tcp(127.0.0.1:3306)/test?charset=utf8")</span><br><span class="line">	ErrHandle(err, "connection mysql faild")</span><br><span class="line">	defer func() {</span><br><span class="line">		err = db.Close()</span><br><span class="line">		ErrHandle(err, "db.close()")</span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	// 新增操作</span><br><span class="line">	// 准备sql语句</span><br><span class="line">	insertSQL := "insert into person (`username`,`sex`,`email`) VALUES (?,?,?)"</span><br><span class="line">	// 预执行语句，stmt的主要方法:Exec、Query、QueryRow、Close返回*Stmt声明句柄，stmt的主要方法:Exec、Query、QueryRow、Close</span><br><span class="line">	stmt, err := db.Prepare(insertSQL)</span><br><span class="line">	ErrHandle(err, "dn.prepar(insertSQL)")</span><br><span class="line">	// 执行</span><br><span class="line">	result, err := stmt.Exec("database/sql", "man", "1@qq.com")</span><br><span class="line">	ErrHandle(err, "stmt.Exec(insertSQL)")</span><br><span class="line">	// 获取插入结果的id</span><br><span class="line">	id, err := result.LastInsertId()</span><br><span class="line">	ErrHandle(err, "LastInsertId()")</span><br><span class="line">	fmt.Println("LastInsertId:", id)</span><br><span class="line"></span><br><span class="line">	// 修改操作</span><br><span class="line">	updataSQL := "UPDATE PERSON SET sex = ? WHERE user_id = ?"</span><br><span class="line">	// 预执行语句</span><br><span class="line">	stmt, err = db.Prepare(updataSQL)</span><br><span class="line">	ErrHandle(err, "db.prepar(updataSQL)")</span><br><span class="line">	// 执行 修改上面新增的数据</span><br><span class="line">	result, err = stmt.Exec("woman", id)</span><br><span class="line">	ErrHandle(err, "stmt.Exec(updataSQL)")</span><br><span class="line">	id, err = result.RowsAffected()</span><br><span class="line">	ErrHandle(err, "RowsAffected()")</span><br><span class="line">	fmt.Println("RowsAffected:", id)</span><br><span class="line"></span><br><span class="line">	// 查询操作</span><br><span class="line">	// 1. 查询一条记录 必须定义一个用来接收查询结果的变量</span><br><span class="line">	resultPerson := new(Person)</span><br><span class="line">	// 准备SQL语句</span><br><span class="line">	querySQL := "SELECT person.username, person.sex, person.email FROM person WHERE user_id =?"</span><br><span class="line">	//查询一条，返回一条结果。并赋值到resultPerson这个结构体类型的变量中,就算查询到的是多条，返回的还是一条</span><br><span class="line">	err = db.QueryRow(querySQL, id).Scan(&amp;resultPerson.UserName, &amp;resultPerson.Sex, &amp;resultPerson.Email)</span><br><span class="line">	ErrHandle(err, "db.QueryRow(querySQL)")</span><br><span class="line">	fmt.Printf("[query row]:%v\n", resultPerson)</span><br><span class="line"></span><br><span class="line">	// 2. 查询多条记录</span><br><span class="line">	querySQL = "SELECT * FROM person"</span><br><span class="line">	// 执行查询,返回多行</span><br><span class="line">	queryRows, err := db.Query(querySQL)</span><br><span class="line">	ErrHandle(err, "db.Query")</span><br><span class="line">	defer func() {</span><br><span class="line">		err = queryRows.Close()</span><br><span class="line">		ErrHandle(err, "queryRows.Close()")</span><br><span class="line">	}()</span><br><span class="line">	// 遍历结果集 *Rows.NEXT() bool</span><br><span class="line">	for queryRows.Next() {</span><br><span class="line">		err = queryRows.Scan(&amp;resultPerson.UserID, &amp;resultPerson.UserName, &amp;resultPerson.Sex, &amp;resultPerson.Email)</span><br><span class="line">		ErrHandle(err, "queryRows.Scan(&amp;resultPerson)")</span><br><span class="line">		fmt.Printf("[query rows]:%v\n\n", resultPerson)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	// 删除操作</span><br><span class="line">	delSQL := "delete from person where user_id = ?"</span><br><span class="line">	stmt, err = db.Prepare(delSQL)</span><br><span class="line">	ErrHandle(err, "db.Prepare(delSQL)")</span><br><span class="line">	// 执行 删除上面新增的数据</span><br><span class="line">	result, err = stmt.Exec(id)</span><br><span class="line">	ErrHandle(err, "stmt.Exec(delSQL)")</span><br><span class="line">	id, err = result.RowsAffected()</span><br><span class="line">	ErrHandle(err, "RowsAffected()")</span><br><span class="line">	fmt.Println("RowsAffected:", id)</span><br><span class="line"></span><br><span class="line">	// 事务操作</span><br><span class="line">	// 开启事务</span><br><span class="line">	tx, err := db.Begin()</span><br><span class="line">	ErrHandle(err, "db.Begin()")</span><br><span class="line">	// 开始事务操作</span><br><span class="line">	_, err1 := tx.Exec("UPDATE PERSON SET sex = ? WHERE user_id = ?", "woman", id)</span><br><span class="line">	_, err2 := tx.Exec("DELETE FROM person WHERE user_id =  ?", id)</span><br><span class="line">	if err1 != nil || err2 != nil {</span><br><span class="line">		fmt.Println("事务操作出错,开始回滚")</span><br><span class="line">		// 事务回滚</span><br><span class="line">		tx.Rollback()</span><br><span class="line">	} else {</span><br><span class="line">		// 事务提交</span><br><span class="line">		tx.Commit()</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-jmoiron-sqlx”第三方包"><a href="#2-jmoiron-sqlx”第三方包" class="headerlink" title="2.jmoiron/sqlx”第三方包"></a>2.jmoiron/sqlx”第三方包</h3><blockquote>
<p>sqlx为对database/sql的封装，提高对sql支持的易用性。其使用方式和database/sql相差不大。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"os"</span><br><span class="line"></span><br><span class="line">	_ "github.com/go-sql-driver/mysql"</span><br><span class="line">	"github.com/jmoiron/sqlx"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Person pojo</span><br><span class="line">type Person struct {</span><br><span class="line">	UserID   int    `db:"user_id"`</span><br><span class="line">	UserName string `db:"username"`</span><br><span class="line">	Sex      string `db:"sex"`</span><br><span class="line">	Email    string `db:"email"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *Person) String() string {</span><br><span class="line">	return string(p.UserID) + p.UserName + p.Sex + p.Email</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Db mysql连接</span><br><span class="line">var Db *sqlx.DB</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">func init() {</span><br><span class="line">	// 初始化连接</span><br><span class="line">	database, err := sqlx.Open("mysql", "root:toor@tcp(127.0.0.1:3306)/test")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("connection mysql faild:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	Db = database</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// ErrHandle 通用错误处理</span><br><span class="line">func ErrHandle(err error, where string) {</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("[Err]:", err, where)</span><br><span class="line">		os.Exit(0)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 新增</span><br><span class="line">func insert() {</span><br><span class="line">	result, err := Db.Exec("insert into person (`username`,`sex`,`email`) VALUES (?,?,?)", "stu03", "man", "stu03@qq.com")</span><br><span class="line">	ErrHandle(err, "mysql insert")</span><br><span class="line">	id, err := result.LastInsertId()</span><br><span class="line">	ErrHandle(err, "result.LastInsertId()")</span><br><span class="line">	fmt.Println("LastInsertId:", id)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 修改</span><br><span class="line">func updata() {</span><br><span class="line">	result, err := Db.Exec("UPDATE PERSON SET sex = ? WHERE user_id = ?", "woman", 1)</span><br><span class="line">	ErrHandle(err, "mysql updata")</span><br><span class="line">	id, err := result.RowsAffected()</span><br><span class="line">	ErrHandle(err, "result.RowsAffected()")</span><br><span class="line">	fmt.Println("RowsAffected:", id)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">func del() {</span><br><span class="line">	result, err := Db.Exec("delete from person where user_id =  ?", 6)</span><br><span class="line">	ErrHandle(err, "mysql delete")</span><br><span class="line">	id, err := result.RowsAffected()</span><br><span class="line">	ErrHandle(err, "result.RowsAffected()")</span><br><span class="line">	fmt.Println("RowsAffected:", id)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 查询</span><br><span class="line">func query() {</span><br><span class="line">	// 定义一个slice接收查询结果</span><br><span class="line">	var ps []Person</span><br><span class="line">	err := Db.Select(&amp;ps, "SELECT person.username, person.sex, person.email FROM person WHERE user_id =?", 1)</span><br><span class="line">	ErrHandle(err, "mysql select")</span><br><span class="line">	fmt.Println(ps)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	insert()</span><br><span class="line">	updata()</span><br><span class="line">	del()</span><br><span class="line">	query()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="sqlx对事务的操作非常简单："><a href="#sqlx对事务的操作非常简单：" class="headerlink" title="sqlx对事务的操作非常简单："></a>sqlx对事务的操作非常简单：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"os"</span><br><span class="line"></span><br><span class="line">	_ "github.com/go-sql-driver/mysql"</span><br><span class="line">	"github.com/jmoiron/sqlx"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Person pojo</span><br><span class="line">type Person struct {</span><br><span class="line">	UserID   int    `db:"user_id"`</span><br><span class="line">	UserName string `db:"username"`</span><br><span class="line">	Sex      string `db:"sex"`</span><br><span class="line">	Email    string `db:"email"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *Person) String() string {</span><br><span class="line">	return string(p.UserID) + p.UserName + p.Sex + p.Email</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Db mysql连接连接池</span><br><span class="line">var Db *sqlx.DB</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">func init() {</span><br><span class="line">	// 初始化连接</span><br><span class="line">	database, err := sqlx.Open("mysql", "root:toor@tcp(127.0.0.1:3306)/test")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("connection mysql faild:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Db = database</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// ErrHandle 错误处理</span><br><span class="line">func ErrHandle(err error, where string) {</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("[ERR]:", err, where)</span><br><span class="line">		os.Exit(0)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 事务管理</span><br><span class="line">func mysqlTransaction() {</span><br><span class="line">	// 开启事务</span><br><span class="line">	tx, err := Db.Begin()</span><br><span class="line">	ErrHandle(err, "db.begin")</span><br><span class="line"></span><br><span class="line">	// 开始事务操作</span><br><span class="line">	_, err1 := tx.Exec("UPDATE PERSON SET sex = ? WHERE user_id = ?", "woman", 1)</span><br><span class="line">	_, err2 := tx.Exec("DELETE FROM person WHERE user_id =  ?", 1)</span><br><span class="line">	if err1 != nil || err2 != nil {</span><br><span class="line">		fmt.Println("事务操作出错,开始回滚")</span><br><span class="line">		// 事务回滚</span><br><span class="line">		tx.Rollback()</span><br><span class="line">	} else {</span><br><span class="line">		// 事务提交</span><br><span class="line">		tx.Commit()</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	mysqlTransaction()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="sqlx自带连接池管理，在项目中可直接用连接池管理对mysql的访问，以实现对IO的访问控制："><a href="#sqlx自带连接池管理，在项目中可直接用连接池管理对mysql的访问，以实现对IO的访问控制：" class="headerlink" title="sqlx自带连接池管理，在项目中可直接用连接池管理对mysql的访问，以实现对IO的访问控制："></a>sqlx自带连接池管理，在项目中可直接用连接池管理对mysql的访问，以实现对IO的访问控制：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"os"</span><br><span class="line">	"time"</span><br><span class="line"></span><br><span class="line">	_ "github.com/go-sql-driver/mysql"</span><br><span class="line">	"github.com/jmoiron/sqlx"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var db *sqlx.DB</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	database, err := sqlx.Open("mysql", "root:toor@tcp(127.0.0.1:3306)/test")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("connection mysql faild")</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	//设置最大打开的连接数，设置最大的连接数，可以避免并发太高导致连接mysql出现too many connections的错误。默认值为0表示不限制。</span><br><span class="line">	database.SetMaxOpenConns(512)</span><br><span class="line">	// 设置最大空闲连接数</span><br><span class="line">	database.SetMaxIdleConns(64)</span><br><span class="line">	// 设置超时时间</span><br><span class="line">	database.SetConnMaxLifetime(time.Second * 60)</span><br><span class="line"></span><br><span class="line">	db = database</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// ErrHandle 错误处理</span><br><span class="line">func ErrHandle(err error, where string) {</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("[ERR]:", err, where)</span><br><span class="line">		os.Exit(0)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func insert() {</span><br><span class="line">	result, err := db.Exec("insert into person (`username`,`sex`,`email`) VALUES (?,?,?)", "stu03", "man", "stu03@qq.com")</span><br><span class="line">	ErrHandle(err, "mysql insert")</span><br><span class="line">	id, err := result.LastInsertId()</span><br><span class="line">	ErrHandle(err, "result.LastInsertId()")</span><br><span class="line">	fmt.Println("LastInsertId:", id)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	insert()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h3><h4 id="3-gorm第三方包"><a href="#3-gorm第三方包" class="headerlink" title="3.gorm第三方包"></a>3.gorm第三方包</h4><blockquote>
<p>ORM（Object Relation Mapping）中文翻译为对象关系映射，这是一种把数据库记录映射为对象类型的一种技术，它把对数据的的操作变成对对象的操作，而不用在意其内部的sql语句，这对许多基于OOP开发的程序员无疑是福音。go非常热门的orm框架 github.com/jinzhu/gorm ，已经实现了全功能的orm，使用方式请直接参考开发文档，该文档已提供中文支持：<a href="https://gorm.io/zh_CN/docs/index.html%E3%80%82">https://gorm.io/zh_CN/docs/index.html。</a> 下面我们来简单使用一下其基本功能。</p>
</blockquote>
<blockquote>
<p>安装库：go get -u github.com/jinzhu/gorm</p>
</blockquote>
<h4 id="导入库及设置连接池："><a href="#导入库及设置连接池：" class="headerlink" title="导入库及设置连接池："></a>导入库及设置连接池：</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//导入库与mysql驱动</span><br><span class="line">import(</span><br><span class="line">_ "github.com/jinzhu/gorm/dialects/mysql"</span><br><span class="line">"github.com/jinzhu/gorm"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义一个通用的错误处理函数</span><br><span class="line">func ErrorHandler(err error, where string) {</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("出现错误：", err, where)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//连接数据库</span><br><span class="line">var db *gorm.DB</span><br><span class="line">//包初始化时连接</span><br><span class="line">func init() {</span><br><span class="line">    var err error</span><br><span class="line">    db, err = gorm.Open("mysql", "&lt;username&gt;:&lt;password&gt;/&lt;database&gt;?charset=utf8&amp;parseTime=True&amp;loc=Local")</span><br><span class="line">    ErrorHandler(err,"gorm.Open()")</span><br><span class="line">    </span><br><span class="line">    //database/sql 已内置连接池设置</span><br><span class="line">    db.DB().SetMaxIdleConns(20)</span><br><span class="line">    db.DB().SetMaxOpenConns(100)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="模型定义："><a href="#模型定义：" class="headerlink" title="模型定义："></a>模型定义：</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//通过标签设置 mysql 里面的约束</span><br><span class="line">type User struct {</span><br><span class="line">    gorm.Model //嵌入gorm基础模型，可获得模型基础能力</span><br><span class="line">    Name   string `gorm:"type:varchar(12);not null;unique_index"`</span><br><span class="line">    Email  string `gorm:"type:varchar(24);unique_index"`</span><br><span class="line">    Phone  string `gorm:"type:varchar(11);unique_index"`</span><br><span class="line">    Avatar string `gorm:"type:varchar(64)"`</span><br><span class="line">    Title  string `gorm:"type:varchar(20)"`</span><br><span class="line">    Gender int32  `gorm:"type:varchar(2)"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="表操作："><a href="#表操作：" class="headerlink" title="表操作："></a>表操作：</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//创建表</span><br><span class="line">if !db.HasTable(&amp;User{}) {</span><br><span class="line">    err := db.Set("gorm:table_options", "ENGINE=InnoDB DEFAULT CHARSET=utf8").CreateTable(&amp;User{}).Error</span><br><span class="line">    ErrorHandler(err,"CreateTable()")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1.插入操作</span><br><span class="line">user := &amp;User{</span><br><span class="line">    Name: "fun",</span><br><span class="line">    Email:"xxx@xxx.com",</span><br><span class="line">    Phone:"13813812138",</span><br><span class="line">    Avatar:"link/to/your/avatar.jpg",</span><br><span class="line">    Title:"Gopher",</span><br><span class="line">    Gender:1</span><br><span class="line">    CreatedAt: time.Now(),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if err := db.Create(user).Error; err != nil {</span><br><span class="line">    log.Println("Create data fail!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//2.更新操作</span><br><span class="line">// UPDATE users SET name='joker', updated_at='2016-04-20 22:12:52' WHERE id=1;</span><br><span class="line">db.Model(&amp;user).Update("name", "joker")</span><br><span class="line">// UPDATE users SET name='joker',title='Coder', updated_at='2016-04-20 22:12:52' WHERE id=1;</span><br><span class="line">db.Model(&amp;user).Updates(User{Name: "joker", Title: "Coder"})</span><br><span class="line"></span><br><span class="line">//3.查询操作</span><br><span class="line">//通过主键查询第一条记录</span><br><span class="line">db.First(&amp;user)</span><br><span class="line">//// SELECT * FROM users ORDER BY id LIMIT 1;</span><br><span class="line">// 随机取一条记录</span><br><span class="line">db.Take(&amp;user)</span><br><span class="line">//// SELECT * FROM users LIMIT 1;</span><br><span class="line">// 通过主键查询最后一条记录</span><br><span class="line">db.Last(&amp;user)</span><br><span class="line">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span><br><span class="line">// 拿到所有的记录</span><br><span class="line">db.Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users;</span><br><span class="line">// 查询指定的某条记录(只可在主键为整数型时使用)</span><br><span class="line">db.First(&amp;user, 10)</span><br><span class="line">//// SELECT * FROM users WHERE id = 10;</span><br><span class="line"></span><br><span class="line">//条件查询</span><br><span class="line">// 获取单条记录</span><br><span class="line">db.Where("name = ?", "fun").First(&amp;user)</span><br><span class="line">// SELECT * FROM users WHERE name = 'fun' limit 1;</span><br><span class="line">// 获取多条记录</span><br><span class="line">db.Where("name = ?", "fun").Find(&amp;users)</span><br><span class="line">//// SELECT * FROM users WHERE name = 'fun';</span><br><span class="line">// &lt;&gt;</span><br><span class="line">db.Where("name &lt;&gt; ?", "fun").Find(&amp;users)</span><br><span class="line">// IN</span><br><span class="line">db.Where("name IN (?)", []string{"fun", "joker"}).Find(&amp;users)</span><br><span class="line">// LIKE</span><br><span class="line">db.Where("name LIKE ?", "%f%").Find(&amp;users)</span><br><span class="line">// AND</span><br><span class="line">db.Where("name = ? AND age &gt;= ?", "fun", "18").Find(&amp;users)</span><br><span class="line">// Time</span><br><span class="line">db.Where("updated_at &gt; ?", lastWeek).Find(&amp;users)</span><br><span class="line">// BETWEEN</span><br><span class="line">db.Where("created_at BETWEEN ? AND ?", lastWeek, today).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4.删除操作</span><br><span class="line">// 删除一条</span><br><span class="line">db.Delete(&amp;user)</span><br><span class="line">// DELETE from users where id=1;</span><br><span class="line">//条件删除多条</span><br><span class="line">db.Where("name LIKE ?", "%fun%").Delete(User{})</span><br><span class="line">// DELETE from users where name LIKE "%f%";</span><br><span class="line">//条件删除多条</span><br><span class="line">db.Delete(User{}, "name LIKE ?", "%fun%")</span><br><span class="line">// DELETE from users where name LIKE "%fun%";</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
        <category>示例</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go连接redis</title>
    <url>/2020/11/14/Golang/%E7%A4%BA%E4%BE%8B/Go%E8%BF%9E%E6%8E%A5redis/</url>
    <content><![CDATA[<h3 id="Go使用redis"><a href="#Go使用redis" class="headerlink" title="Go使用redis"></a>Go使用redis</h3><p>github地址：<br><a href="https://github.com/garyburd/redigo">https://github.com/garyburd/redigo</a></p>
<p>文档地址：<br><a href="http://godoc.org/github.com/garyburd/redigo/redis">http://godoc.org/github.com/garyburd/redigo/redis</a></p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取:"></a>获取:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go get github.com/garyburd/redigo/redis</span><br></pre></td></tr></tbody></table></figure>
<h3 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis:"></a>连接redis:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func connectRedis() {</span><br><span class="line">	// 连接redis</span><br><span class="line">	conn, err := redis.Dial("tcp", "127.0.0.1:6379")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("connect redis error:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer conn.Close()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="读写"><a href="#读写" class="headerlink" title="读写:"></a>读写:</h3><p>这里写入的值不会过期</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">func readWriteRedis() {</span><br><span class="line">	// 链接redis</span><br><span class="line">	conn, err := redis.Dial("tcp", "127.0.0.1:6379")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("connect redis error:%s\n", err)</span><br><span class="line">	}</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	// 写入一个key为“mykey”,value为10的键值对 这里写入的键值对永远不会过期</span><br><span class="line">	_, err = conn.Do("SET", "mykey", 10)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("redis set failed:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	v, err := redis.Int(conn.Do("GET", "mykey"))</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("redis get failed:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("get mykey value:%d\n", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	readWriteRedis()</span><br><span class="line">}</span><br><span class="line">---------------------</span><br><span class="line">get mykey value:10</span><br></pre></td></tr></tbody></table></figure>
<p>如何设置过期呢，可以使用SET的附加参数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func readWriteRedisEx() {</span><br><span class="line">	// 链接redis</span><br><span class="line">	conn, err := redis.Dial("tcp", "127.0.0.1:6379")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("connect redis error:%s\n", err)</span><br><span class="line">	}</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	// 写入一个Key并设置它的过期时间</span><br><span class="line">	_, err = conn.Do("SET", "extime", 5, "EX", "5")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("redis set failed:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	v, err := redis.Int(conn.Do("GET", "extime"))</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("redis get failed:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("get mykey value:%d\n", v)</span><br><span class="line">	// 睡眠5秒再次读取</span><br><span class="line">	time.Sleep(time.Second * 6)</span><br><span class="line"></span><br><span class="line">	v, err = redis.Int(conn.Do("GET", "extime"))</span><br><span class="line">	if err != nil {</span><br><span class="line">		// 由于key设置了超时时间是5秒  这里无法读到key的值</span><br><span class="line">		fmt.Printf("redis get failed:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("get mykey value:%d\n", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	readWriteRedisEx()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">get mykey value:5</span><br><span class="line">redis get failed:redigo: nil returned</span><br></pre></td></tr></tbody></table></figure>
<h3 id="批量写入-读取"><a href="#批量写入-读取" class="headerlink" title="批量写入 读取"></a>批量写入 读取</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func batchReadWriteRedis() {</span><br><span class="line">	conn, err := redis.Dial("tcp", "127.0.0.1:6379")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("connect redis error:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	// 批量设置key</span><br><span class="line">	_, err = conn.Do("MSET", "mykey1", "key1", "mykey2", "key2", "mykey3", "key3")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("redis mset failed:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 批量读取</span><br><span class="line">	v, err := redis.Strings(conn.Do("MGET", "mykey1", "mykey2", "mykey3"))</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("redis mget faild:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	for index, val := range v {</span><br><span class="line">		fmt.Printf("the %d value is:%s\n", index, val)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	batchReadWriteRedis()</span><br><span class="line">}</span><br><span class="line">-------------------------------------</span><br><span class="line">the 0 value is:key1</span><br><span class="line">the 1 value is:key2</span><br><span class="line">the 2 value is:key3</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用redis连接池，EXISTS检测值是否存在"><a href="#使用redis连接池，EXISTS检测值是否存在" class="headerlink" title="使用redis连接池，EXISTS检测值是否存在"></a>使用redis连接池，EXISTS检测值是否存在</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	"encoding/json"</span><br><span class="line">	"fmt"</span><br><span class="line">	"time"</span><br><span class="line"></span><br><span class="line">	"github.com/garyburd/redigo/redis"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var pool *redis.Pool</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	pool = &amp;redis.Pool{</span><br><span class="line">		// 最大空闲连接数</span><br><span class="line">		MaxIdle: 16,</span><br><span class="line">		//池在给定时间分配的最大连接数。当为零时，池中的连接数没有限制。</span><br><span class="line">		MaxActive: 0,</span><br><span class="line">		//在此期间保持空闲后关闭连接。 如果该值为零，则不关闭空闲连接。 应用程序应将超时设置为小于服务器超时的值。</span><br><span class="line">		IdleTimeout: 300,</span><br><span class="line">		// Dial是应用程序提供的功能，用于创建和配置连接。 从Dial返回的连接不能处于特殊状态（订阅pubsub通道，事务已启动，...）。</span><br><span class="line">		Dial: func() (redis.Conn, error) {</span><br><span class="line">			return redis.Dial("tcp", "127.0.0.1:6379")</span><br><span class="line">		},</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 使用连接池</span><br><span class="line">func existsKey() {</span><br><span class="line">	// 从连接池中获取连接</span><br><span class="line">	conn := pool.Get()</span><br><span class="line">	// 用完后把连接放回连接池</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	b, err := redis.Bool(conn.Do("EXISTS", "mykey"))</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("redis exists error:%s\n", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	if b {</span><br><span class="line">		fmt.Println("key exist")</span><br><span class="line">	} else {</span><br><span class="line">		fmt.Println("Key does not exist")</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	existsKey()</span><br><span class="line">}</span><br><span class="line">----------------------------</span><br><span class="line">key exist</span><br></pre></td></tr></tbody></table></figure>

<h3 id="把json写到redis"><a href="#把json写到redis" class="headerlink" title="把json写到redis"></a>把json写到redis</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	"encoding/json"</span><br><span class="line">	"fmt"</span><br><span class="line">	"time"</span><br><span class="line"></span><br><span class="line">	"github.com/garyburd/redigo/redis"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var pool *redis.Pool</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	pool = &amp;redis.Pool{</span><br><span class="line">		// 最大空闲连接数</span><br><span class="line">		MaxIdle: 16,</span><br><span class="line">		//池在给定时间分配的最大连接数。当为零时，池中的连接数没有限制。</span><br><span class="line">		MaxActive: 0,</span><br><span class="line">		//在此期间保持空闲后关闭连接。 如果该值为零，则不关闭空闲连接。 应用程序应将超时设置为小于服务器超时的值。</span><br><span class="line">		IdleTimeout: 300,</span><br><span class="line">		// Dial是应用程序提供的功能，用于创建和配置连接。 从Dial返回的连接不能处于特殊状态（订阅pubsub通道，事务已启动，...）。</span><br><span class="line">		Dial: func() (redis.Conn, error) {</span><br><span class="line">			return redis.Dial("tcp", "127.0.0.1:6379")</span><br><span class="line">		},</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 把json写到redis</span><br><span class="line">func jsonToRedis() {</span><br><span class="line">	key := "stu01"</span><br><span class="line">	imap := map[string]string{"username": "张三", "age": "10", "phone": "13773943000"}</span><br><span class="line">	value, err := json.Marshal(imap)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("map to json error")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	conn := pool.Get()</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	_, err = conn.Do("SET", key, value)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("set key error")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	v, err := redis.String(conn.Do("GET", key))</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("get key error")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Println("value is:", v)</span><br><span class="line">}</span><br><span class="line">------------------------------</span><br><span class="line">value is: {"age":"10","phone":"13773943000","username":"张三"}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="为已存在的key设置过期时间"><a href="#为已存在的key设置过期时间" class="headerlink" title="为已存在的key设置过期时间"></a>为已存在的key设置过期时间</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	"encoding/json"</span><br><span class="line">	"fmt"</span><br><span class="line">	"time"</span><br><span class="line"></span><br><span class="line">	"github.com/garyburd/redigo/redis"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var pool *redis.Pool</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	pool = &amp;redis.Pool{</span><br><span class="line">		// 最大空闲连接数</span><br><span class="line">		MaxIdle: 16,</span><br><span class="line">		//池在给定时间分配的最大连接数。当为零时，池中的连接数没有限制。</span><br><span class="line">		MaxActive: 0,</span><br><span class="line">		//在此期间保持空闲后关闭连接。 如果该值为零，则不关闭空闲连接。 应用程序应将超时设置为小于服务器超时的值。</span><br><span class="line">		IdleTimeout: 300,</span><br><span class="line">		// Dial是应用程序提供的功能，用于创建和配置连接。 从Dial返回的连接不能处于特殊状态（订阅pubsub通道，事务已启动，...）。</span><br><span class="line">		Dial: func() (redis.Conn, error) {</span><br><span class="line">			return redis.Dial("tcp", "127.0.0.1:6379")</span><br><span class="line">		},</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func setExpire() {</span><br><span class="line">	conn := pool.Get()</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	// 这里单位是秒</span><br><span class="line">	_, err := conn.Do("EXPIRE", "mykey", 5)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("redus expire error")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	setExpire()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>示例</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的结构体《一》</title>
    <url>/2020/11/14/Golang/%E7%BB%93%E6%9E%84%E4%BD%93/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%8A%E4%B8%80%E3%80%8B/</url>
    <content><![CDATA[<h3 id="结构体的声明"><a href="#结构体的声明" class="headerlink" title="结构体的声明"></a>结构体的声明</h3><blockquote>
<p>结构体标识符和结构体内的字段,如果大写,则表示公共的,可以在其他包内访问,否则是私有的</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	结构体的声明</span><br><span class="line">	type 标识符 struct{</span><br><span class="line">		field1 type</span><br><span class="line">		field2 type</span><br><span class="line">	}</span><br><span class="line">*/</span><br><span class="line">type student struct {</span><br><span class="line">	name string</span><br><span class="line">	age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test1() {</span><br><span class="line">	// 结构体定义的三种方式</span><br><span class="line">	var stu student</span><br><span class="line">	stu.name = "方式1"</span><br><span class="line">	stu.age = 18</span><br><span class="line">	fmt.Printf("stu[name:%s,age:%d]\n", stu.name, stu.age)</span><br><span class="line"></span><br><span class="line">	// 通过new关键字创建的结构体，返回的是地址,所以这里的stu1是指向地址的指针</span><br><span class="line">	stu1 := new(student)</span><br><span class="line">	(*stu1).name = "方式2"</span><br><span class="line">	(*stu1).age = 18</span><br><span class="line">	fmt.Printf("stu1[name:%s,age:%d]\n", (*stu1).name, (*stu1).age)</span><br><span class="line"></span><br><span class="line">	stu2 := &amp;student{</span><br><span class="line">		name: "方式3",</span><br><span class="line">		age:  18,</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("stu2[name:%s,age:%d]\n", (*stu2).name, (*stu2).age)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test1()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的结构体《三》</title>
    <url>/2020/11/14/Golang/%E7%BB%93%E6%9E%84%E4%BD%93/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%8A%E4%B8%89%E3%80%8B/</url>
    <content><![CDATA[<h3 id="struct的方法"><a href="#struct的方法" class="headerlink" title="struct的方法"></a>struct的方法</h3><blockquote>
<p>Golang中的方法是作用在特定类型的变量上，因此自定义类型，都可以有方法，而不仅仅是struct<br>定义：func (recevier type) methodName(参数列表)(返回值列表){}</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type student struct {</span><br><span class="line">	name  string</span><br><span class="line">	age   int</span><br><span class="line">	score int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *student) init(name string, age, score int) {</span><br><span class="line">	p.name = name</span><br><span class="line">	p.age = age</span><br><span class="line">	p.score = score</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p student) getName() string {</span><br><span class="line">	return p.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p student) print() {</span><br><span class="line">	fmt.Println("p is :", p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var stu student</span><br><span class="line">	stu.init("张三", 18, 61)</span><br><span class="line">	stu.print()</span><br><span class="line">	name := stu.getName()</span><br><span class="line">	fmt.Printf("stu name:%s\n", name)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="struct的继承"><a href="#struct的继承" class="headerlink" title="struct的继承"></a>struct的继承</h3><blockquote>
<p>如果一个struct嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的方法，从而实现了继承。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type car struct {</span><br><span class="line">	brand string</span><br><span class="line">	model string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type train struct {</span><br><span class="line">	car</span><br><span class="line">	wheel int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p car) run() {</span><br><span class="line">	fmt.Printf("%s run....\n", p.brand)</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">	var tr train</span><br><span class="line">	tr.brand = "火车"</span><br><span class="line">	tr.model = "长"</span><br><span class="line">	tr.wheel = 50</span><br><span class="line">	tr.run()</span><br><span class="line">}</span><br><span class="line">------</span><br><span class="line">火车 run....</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>如果一个struct嵌套了另一个有名结构体，那么这个模式就叫组合。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type car struct {</span><br><span class="line">	brand string</span><br><span class="line">	model string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type audi struct {</span><br><span class="line">	c     car</span><br><span class="line">	wheel int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p car) run() {</span><br><span class="line">	fmt.Printf("%s run....\n", p.brand)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var ad audi</span><br><span class="line">	ad.c.brand = "奥迪"</span><br><span class="line">	ad.c.model = "suv"</span><br><span class="line">	ad.wheel = 4</span><br><span class="line">	ad.c.run()</span><br><span class="line">}</span><br><span class="line">------</span><br><span class="line">奥迪 run....</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现一个简单的二叉树</title>
    <url>/2020/11/14/Golang/%E7%BB%93%E6%9E%84%E4%BD%93/Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Node struct {</span><br><span class="line">	Value       int</span><br><span class="line">	Left, Right *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func createNode(value int) *Node {</span><br><span class="line">	return &amp;Node{</span><br><span class="line">		Value: value,</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func traversing(root *Node) {</span><br><span class="line"></span><br><span class="line">	if root == nil {</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 中序遍历</span><br><span class="line">	traversing(root.Left)</span><br><span class="line">	fmt.Printf("%d\n", root.Value)</span><br><span class="line">	traversing(root.Right)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var root *Node = createNode(3)</span><br><span class="line">	root.Left = createNode(1)</span><br><span class="line">	root.Right = createNode(5)</span><br><span class="line">	root.Left.Left = createNode(0)</span><br><span class="line">	root.Left.Right = createNode(2)</span><br><span class="line">	root.Right.Left = createNode(4)</span><br><span class="line">	root.Right.Right = createNode(6)</span><br><span class="line"></span><br><span class="line">	traversing(root)</span><br><span class="line">}</span><br><span class="line">------------------</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>上述代码在创建并初始化的二叉树结构如下图<br><img src="http://files.codedog.link/blog/typecho/%E4%BA%8C%E5%8F%89%E6%A0%91.png-suofang" alt="Go语言创建一个简单的二叉树" title="二叉树"></p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现一个简单的单向链表</title>
    <url>/2020/11/14/Golang/%E7%BB%93%E6%9E%84%E4%BD%93/Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="单向链表的遍历、新增、删除操作"><a href="#单向链表的遍历、新增、删除操作" class="headerlink" title="单向链表的遍历、新增、删除操作"></a>单向链表的遍历、新增、删除操作</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type linkedlist struct {</span><br><span class="line">	value string</span><br><span class="line">	next  *linkedlist</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 遍历链表</span><br><span class="line">func traversing(link *linkedlist) {</span><br><span class="line">	fmt.Printf("%s\n", (*link).value)</span><br><span class="line">	if link.next != nil {</span><br><span class="line">		traversing(link.next)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 在链表最后插入一个元素</span><br><span class="line">func insertLink(root, target *linkedlist) *linkedlist {</span><br><span class="line">	if root.next != nil {</span><br><span class="line">		insertLink(root.next, target)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	if root.next == nil {</span><br><span class="line">		root.next = target</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	return root</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 删除指定value节点</span><br><span class="line">func delLink(root *linkedlist, name string) {</span><br><span class="line">	var prev *linkedlist = root</span><br><span class="line">	for root != nil {</span><br><span class="line">		if root.value == name {</span><br><span class="line">			prev.next = root.next</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line">		prev = root</span><br><span class="line">		root = root.next</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test1() {</span><br><span class="line">	link := &amp;linkedlist{</span><br><span class="line">		value: "1",</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	s := &amp;linkedlist{</span><br><span class="line">		value: "2",</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	s1 := &amp;linkedlist{</span><br><span class="line">		value: "3",</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	link.next = s</span><br><span class="line">	s.next = s1</span><br><span class="line">	traversing(link)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test2() {</span><br><span class="line">	var root *linkedlist = &amp;linkedlist{</span><br><span class="line">		value: "root1",</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	var p *linkedlist = root</span><br><span class="line"></span><br><span class="line">	for i := 1; i &lt; 10; i++ {</span><br><span class="line">		var s *linkedlist = &amp;linkedlist{</span><br><span class="line">			value: fmt.Sprintf("s%d", i),</span><br><span class="line">		}</span><br><span class="line">		fmt.Printf("%v\n", s)</span><br><span class="line">		p.next = s</span><br><span class="line">		p = s</span><br><span class="line">	}</span><br><span class="line">	traversing(root)</span><br><span class="line">	delLink(root, "s3")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test3() {</span><br><span class="line">	var root *linkedlist = &amp;linkedlist{</span><br><span class="line">		value: "root1",</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for i := 1; i &lt; 10; i++ {</span><br><span class="line">		var s *linkedlist = &amp;linkedlist{</span><br><span class="line">			value: fmt.Sprintf("s%d", i),</span><br><span class="line">		}</span><br><span class="line">		insertLink(root, s)</span><br><span class="line">	}</span><br><span class="line">	traversing(root)</span><br><span class="line">	fmt.Printf("delete\n")</span><br><span class="line">	delLink(root, "s3")</span><br><span class="line">	traversing(root)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test3()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的结构体《二》</title>
    <url>/2020/11/14/Golang/%E7%BB%93%E6%9E%84%E4%BD%93/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%8A%E4%BA%8C%E3%80%8B/</url>
    <content><![CDATA[<h3 id="struct的注意点"><a href="#struct的注意点" class="headerlink" title="struct的注意点"></a>struct的注意点</h3><blockquote>
<p>结构体是用户单独定义的类型,不能和其他类型进行强制转换</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">type student struct {</span><br><span class="line">	value int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type stu student</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var a student = student{value: 30}</span><br><span class="line">	var b stu = stu{}</span><br><span class="line">	//注意：这段代码的编译无法通过</span><br><span class="line">	a = b</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>struct中没有构造函数,一般可以使用工厂模式来解决这个问题</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">type student struct {</span><br><span class="line">	value int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func CreateStudent(val int) *student {</span><br><span class="line">	return &amp;student{</span><br><span class="line">		value: val,</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var a *student = CreateStudent(1)</span><br><span class="line">	fmt.Printf("a:%v\n", a)</span><br><span class="line">}</span><br><span class="line">------------</span><br><span class="line">a:&amp;{1}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:make只用来创建map、slice、channel new用来创建值类型</p>
</blockquote>
<h3 id="struct中的tag"><a href="#struct中的tag" class="headerlink" title="struct中的tag"></a>struct中的tag</h3><blockquote>
<p>在Go中,如果一个struct需要被序列化成json,则需要其标识符和内部字段的首字母大写,否则Go自带的encoding/json包无法对其访问<br>而首字母大写后,序列化出的json中每个字段的首字母也会大写,这时候就需要使用tag来标识</p>
</blockquote>
<ul>
<li>未使用tag标识的代码如下:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	"encoding/json"</span><br><span class="line">	"fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Student struct {</span><br><span class="line">	Name  string</span><br><span class="line">	Age   int</span><br><span class="line">	Score int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">	var s *Student = &amp;Student{</span><br><span class="line">		Name:  "张三",</span><br><span class="line">		Age:   18,</span><br><span class="line">		Score: 61,</span><br><span class="line">	}</span><br><span class="line">	b, err := json.Marshal(s)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("%s\n", string(b))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test()</span><br><span class="line">}</span><br><span class="line">---------------</span><br><span class="line">{"Name":"张三","Age":18,"Score":61}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>使用tag对struct的字段进行标识:</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Student struct {</span><br><span class="line">	//tag使用的是``反引号进行标识</span><br><span class="line">	Name  string `json:"name"`</span><br><span class="line">	Age   int    `json:"age"`</span><br><span class="line">	Score int    `json:"score"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">	var s *Student = &amp;Student{</span><br><span class="line">		Name:  "张三",</span><br><span class="line">		Age:   18,</span><br><span class="line">		Score: 61,</span><br><span class="line">	}</span><br><span class="line">	b, err := json.Marshal(s)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf("%s\n", string(b))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test()</span><br><span class="line">}</span><br><span class="line">-----------------</span><br><span class="line">{"name":"张三","age":18,"score":61}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意！tag使用``反引号进行标识！</p>
</blockquote>
</li>
</ul>
<h3 id="struct中的匿名字段"><a href="#struct中的匿名字段" class="headerlink" title="struct中的匿名字段"></a>struct中的匿名字段</h3><blockquote>
<p>结构体中的字段可以没有名字,即匿名字段,匿名字段可以通过.类型的方式进行访问和赋值</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Car struct {</span><br><span class="line">	Name string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Train struct {</span><br><span class="line">	Car</span><br><span class="line">	Name  string</span><br><span class="line">	Start time.Time</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func test1() {</span><br><span class="line">	var t Train</span><br><span class="line">	t.Car.Name = "车"</span><br><span class="line">	t.Name = "火车"</span><br><span class="line">	t.Start = time.Now()</span><br><span class="line">	fmt.Printf("%v\n", t)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	test1()</span><br><span class="line">}</span><br><span class="line">-----------------</span><br><span class="line">{{车} 火车 2019-07-09 07:19:08.2539989 +0800 CST m=+0.002012401}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现HTTP服务</title>
    <url>/2020/11/14/Golang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go%E5%AE%9E%E7%8E%B0HTTP%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="Golang创建一个简单的http服务"><a href="#Golang创建一个简单的http服务" class="headerlink" title="Golang创建一个简单的http服务"></a>Golang创建一个简单的http服务</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func hello(resp http.ResponseWriter, req *http.Request) {</span><br><span class="line">	fmt.Fprintf(resp, "hello")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	// 创建http监听 路径  方法</span><br><span class="line">	http.HandleFunc("/", hello)</span><br><span class="line">	// 配置监听地址 ListenAndServe会一直处于挂起状态</span><br><span class="line">	err := http.ListenAndServe("0.0.0.0:8888", nil)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Printf("http err:%s\n", err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="发送一个Http请求"><a href="#发送一个Http请求" class="headerlink" title="发送一个Http请求"></a>发送一个Http请求</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net/http"</span><br><span class="line">	"net/http/httputil"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// http client</span><br><span class="line">func main() {</span><br><span class="line">	res, err := http.Get("http://www.baidu.com/")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("get err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	data, err := httputil.DumpResponse(res, true)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("get data err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(string(data))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>HTTP常见的请求方法:GET、POST、PUT、DELETE、HEAD</p>
</blockquote>
<h3 id="发送一个HEAD请求"><a href="#发送一个HEAD请求" class="headerlink" title="发送一个HEAD请求"></a>发送一个HEAD请求</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var urls = []string{</span><br><span class="line">	"http://www.baidu.com/",</span><br><span class="line">	"http://www.google.com",</span><br><span class="line">	"http://www.taobao.com",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// head 测试url是否能打开</span><br><span class="line">func main() {</span><br><span class="line">	for _, url := range urls {</span><br><span class="line">		resp, err := http.Head(url)</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Println("request err:", err)</span><br><span class="line">			continue</span><br><span class="line">		}</span><br><span class="line">		fmt.Printf("head %s success,status:%d\n", url, resp.StatusCode)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>HEAD请求如果对应URL长时间没有响应,会触发超时处理</p>
</blockquote>
<h3 id="自定义HEAD超时时间"><a href="#自定义HEAD超时时间" class="headerlink" title="自定义HEAD超时时间"></a>自定义HEAD超时时间</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net"</span><br><span class="line">	"net/http"</span><br><span class="line">	"time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var urls = []string{</span><br><span class="line">	"http://www.baidu.com/",</span><br><span class="line">	"http://www.google.com",</span><br><span class="line">	"http://www.taobao.com",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	// 自定义超时时间</span><br><span class="line">	c := http.Client{</span><br><span class="line">		Transport: &amp;http.Transport{</span><br><span class="line">			Dial: func(network, addr string) (conn net.Conn, err error) {</span><br><span class="line">				timeout := time.Second * 3</span><br><span class="line">				return net.DialTimeout(network, addr, timeout)</span><br><span class="line">			},</span><br><span class="line">		},</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for _, url := range urls {</span><br><span class="line">		resp, err := c.Head(url)</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Println("request err:", err)</span><br><span class="line">			continue</span><br><span class="line">		}</span><br><span class="line">		fmt.Printf("head %s success,status:%d\n", url, resp.StatusCode)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="简单的表单处理"><a href="#简单的表单处理" class="headerlink" title="简单的表单处理:"></a>简单的表单处理:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"io"</span><br><span class="line">	"net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 表单处理</span><br><span class="line"></span><br><span class="line">func hello(respWrite http.ResponseWriter, req *http.Request) {</span><br><span class="line">	io.WriteString(respWrite, "hello world ")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func loginHandle(respWrite http.ResponseWriter, req *http.Request) {</span><br><span class="line">	var form = `&lt;!DOCTYPE html&gt;</span><br><span class="line">	&lt;html lang="zh-cn"&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset="UTF-8"&gt;</span><br><span class="line">		&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">		&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span><br><span class="line">		&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;form action="#" method="POST"&gt;</span><br><span class="line">			&lt;input type="text" name="username"&gt;</span><br><span class="line">			&lt;input type="text" name="passwd"&gt;</span><br><span class="line">			&lt;input type="submit" value="登录"&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">	&lt;/html&gt;`</span><br><span class="line">	respWrite.Header().Set("content-type", "text/html; charset=UTF-8")</span><br><span class="line">	switch req.Method {</span><br><span class="line">	case "GET":</span><br><span class="line">		io.WriteString(respWrite, form)</span><br><span class="line">	case "POST":</span><br><span class="line">		req.ParseForm()</span><br><span class="line">		io.WriteString(respWrite, req.FormValue("username"))</span><br><span class="line">		io.WriteString(respWrite, "\n")</span><br><span class="line">		io.WriteString(respWrite, req.FormValue("passwd"))</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	http.HandleFunc("/", hello)</span><br><span class="line">	http.HandleFunc("/login", loginHandle)</span><br><span class="line">	if err := http.ListenAndServe(":8888", nil); err != nil {</span><br><span class="line">		fmt.Println("http server start err:", err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>如果不进行panic处理，某一次请求发生了panic，则会导致整个http服务终止</p>
</blockquote>
<h3 id="panic处理"><a href="#panic处理" class="headerlink" title="panic处理"></a>panic处理</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"io"</span><br><span class="line">	"log"</span><br><span class="line">	"net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func loginHandle(respWriter http.ResponseWriter, req *http.Request) {</span><br><span class="line">	io.WriteString(respWriter, "login")</span><br><span class="line">	panic("login err")</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// panic 处理</span><br><span class="line">func logPanicHandle(hand http.HandlerFunc) http.HandlerFunc {</span><br><span class="line">	return func(respWriter http.ResponseWriter, req *http.Request) {</span><br><span class="line"></span><br><span class="line">		defer func() {</span><br><span class="line">			if err := recover(); err != nil {</span><br><span class="line">				log.Printf("[%v] url:[%v] panic: %v", req.RemoteAddr, req.RequestURI, err)</span><br><span class="line">			}</span><br><span class="line">		}()</span><br><span class="line"></span><br><span class="line">		hand(respWriter, req)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	http.HandleFunc("/login", logPanicHandle(loginHandle))</span><br><span class="line">	err := http.ListenAndServe(":8888", nil)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("server err:", err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现一个并发爬虫</title>
    <url>/2020/11/14/Golang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net/http"</span><br><span class="line">	"os"</span><br><span class="line">	"regexp"</span><br><span class="line">	"strconv"</span><br><span class="line">	"strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func httpGet(url string) (result string, err error) {</span><br><span class="line">	// https://www.gushiwen.org/default_2.aspx</span><br><span class="line"></span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("http.Get() err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	buf := make([]byte, 1024*4)</span><br><span class="line">	for {</span><br><span class="line">		n, err := resp.Body.Read(buf)</span><br><span class="line">		if n == 0 || err != nil {</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line">		result += string(buf[:n])</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 爬取详细内容</span><br><span class="line">func spiderContent(url string) (title, content string) {</span><br><span class="line">	result, err := httpGet(url)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("httpGet() err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 创建正则表达式对象 匹配标题</span><br><span class="line">	re := regexp.MustCompile(`&lt;h1 style="font-size:20px; line-height:22px; height:22px; margin-bottom:10px;"&gt;(?s:(.*?))&lt;/h1&gt;`)</span><br><span class="line">	if re == nil {</span><br><span class="line">		fmt.Println("re is nil")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 使用创建的正则表达式对象对返回的result进行匹配FindAllStringSubmatch(需要匹配的字符串,匹配多少次,-1为匹配所有)</span><br><span class="line">	reTitle := re.FindAllStringSubmatch(result, 1)</span><br><span class="line"></span><br><span class="line">	for _, v := range reTitle {</span><br><span class="line">		title = strings.Replace(v[1], "\t", "", -1)</span><br><span class="line">		title = strings.Replace(title, "\n", "", -1)</span><br><span class="line">		title = strings.Replace(title, "\r", "", -1)</span><br><span class="line">		title = strings.Replace(title, " ", "", -1)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	// 匹配内容</span><br><span class="line">	contsonID := url[32:44]</span><br><span class="line">	re = regexp.MustCompile(`&lt;div class="contson" id="contson` + contsonID + `"&gt;(?s:(.*?))&lt;/div&gt;`)</span><br><span class="line">	if re == nil {</span><br><span class="line">		fmt.Println("re is nil")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	reContent := re.FindAllStringSubmatch(result, 1)</span><br><span class="line"></span><br><span class="line">	for _, v := range reContent {</span><br><span class="line">		content = strings.Replace(v[1], "\t", "", -1)</span><br><span class="line">		content = strings.Replace(content, "\n", "", -1)</span><br><span class="line">		content = strings.Replace(content, "\r", "", -1)</span><br><span class="line">		content = strings.Replace(content, " ", "", -1)</span><br><span class="line">		content = strings.Replace(content, "&lt;br/&gt;", "", -1)</span><br><span class="line">		content = strings.Replace(content, "&lt;p&gt;", "", -1)</span><br><span class="line">		content = strings.Replace(content, "&lt;/p&gt;", "", -1)</span><br><span class="line">	}</span><br><span class="line">	return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func save(index int, titleArr, contentArr []string) {</span><br><span class="line">	f, err := os.Create(strconv.Itoa(index) + ".txt")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("create file errr:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer f.Close()</span><br><span class="line">	n := len(titleArr)</span><br><span class="line">	for i := 0; i &lt; n; i++ {</span><br><span class="line">		f.WriteString(titleArr[i] + "\n")</span><br><span class="line">		f.WriteString(contentArr[i] + "\n")</span><br><span class="line">		f.WriteString("\n")</span><br><span class="line">	}</span><br><span class="line">	return</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 爬取每一页的连接</span><br><span class="line">func spiderPage(index int, isExit chan int) {</span><br><span class="line">	url := "https://www.gushiwen.org/default_" + strconv.Itoa(index) + ".aspx"</span><br><span class="line">	result, err := httpGet(url)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("httpGet() err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 创建正则表达式对象</span><br><span class="line">	re := regexp.MustCompile(`&lt;p&gt;&lt;a style="font-size:18px; line-height:22px; height:22px;" href="(?s:(.*?))"`)</span><br><span class="line">	if re == nil {</span><br><span class="line">		fmt.Println("re is nil")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	reUrls := re.FindAllStringSubmatch(result, -1)</span><br><span class="line"></span><br><span class="line">	titleArr := make([]string, 0)</span><br><span class="line">	contentArr := make([]string, 0)</span><br><span class="line"></span><br><span class="line">	for _, v := range reUrls {</span><br><span class="line">		title, content := spiderContent(v[1])</span><br><span class="line">		titleArr = append(titleArr, title)</span><br><span class="line">		contentArr = append(contentArr, content)</span><br><span class="line">	}</span><br><span class="line">	// 保存到文件</span><br><span class="line">	save(index, titleArr, contentArr)</span><br><span class="line">	isExit &lt;- index</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func doWork(start, end int) {</span><br><span class="line">	fmt.Printf("正在抓取 %d 到 %d 页面数据\n", start, end)</span><br><span class="line"></span><br><span class="line">	isExit := make(chan int)</span><br><span class="line"></span><br><span class="line">	for i := start; i &lt;= end; i++ {</span><br><span class="line">		go spiderPage(i, isExit)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for i := start; i &lt;= end; i++ {</span><br><span class="line">		&lt;-isExit</span><br><span class="line">		fmt.Printf("已经保存了:%d个\n", i)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var start, end int</span><br><span class="line">	fmt.Println("请输入起始页:")</span><br><span class="line">	fmt.Scan(&amp;start)</span><br><span class="line">	fmt.Println("请输入结束页:")</span><br><span class="line">	fmt.Scan(&amp;end)</span><br><span class="line"></span><br><span class="line">	doWork(start, end)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="关于正则表达式的模式修饰符"><a href="#关于正则表达式的模式修饰符" class="headerlink" title="关于正则表达式的模式修饰符:"></a>关于正则表达式的模式修饰符:</h2><ul>
<li>(?i)即匹配时不区分大小写。表示匹配时不区分大小写。</li>
<li>(?s)即Singleline(单行模式)。表示更改.的含义，使它与每一个字符匹配（包括换行 符\n）。</li>
<li>(?m)即Multiline(多行模式) 。 表示更改^和$的 含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的 精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</li>
<li>(?x)：表示如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。</li>
<li>(?e)：表示本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。</li>
<li>(?A)：表示如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说”/a/A”匹配”abcd”。</li>
<li>(?E)：与”m”相反，表示如果使用这个修饰符，那么”$”将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。</li>
<li>(?U)：表示和问号的作用差不多，用于设置”贪婪模式”。</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现一个并发聊天服务器</title>
    <url>/2020/11/14/Golang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p><img src="http://files.codedog.link/blog/typecho/%E5%B9%B6%E5%8F%91%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="Go并发聊天服务器" title="Go并发聊天服务器"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"io"</span><br><span class="line">	"net"</span><br><span class="line">	"strings"</span><br><span class="line">	"time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Client 连接的客户端</span><br><span class="line">type Client struct {</span><br><span class="line">	// 用来存储要发送消息</span><br><span class="line">	C    chan string</span><br><span class="line">	Name string</span><br><span class="line">	Addr string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 用来存储在线的用户</span><br><span class="line">var onlineMap map[string]*Client</span><br><span class="line"></span><br><span class="line">var messages chan string</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	// 初始化map</span><br><span class="line">	onlineMap = make(map[string]*Client)</span><br><span class="line">	// 初始化消息</span><br><span class="line">	messages = make(chan string, 128)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func makeMsg(cli *Client, msg string) string {</span><br><span class="line">	return fmt.Sprintf("用户[%s]:%s\n", cli.Name, msg)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Manager 转发所有消息到用户</span><br><span class="line">func Manager() {</span><br><span class="line">	for {</span><br><span class="line"></span><br><span class="line">		// 如果没有消息  这里会阻塞</span><br><span class="line">		msg := &lt;-messages</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">		// 遍历在线用户 转发消息</span><br><span class="line">		for _, cli := range onlineMap {</span><br><span class="line">			cli.C &lt;- msg</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 把消息发送给对应的用户</span><br><span class="line">func writeMsgToClient(cli *Client, conn net.Conn) {</span><br><span class="line">	for {</span><br><span class="line">		msg := &lt;-cli.C</span><br><span class="line">		_, err := conn.Write([]byte(msg))</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Println("[writeMsgToClient] err:", err)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func readClientMsg(cli *Client, conn net.Conn, isLogout, hasData chan bool) {</span><br><span class="line">	buf := make([]byte, 1024)</span><br><span class="line">	for {</span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		if err != nil {</span><br><span class="line">			if err == io.EOF {</span><br><span class="line">				isLogout &lt;- true</span><br><span class="line">				return</span><br><span class="line">			}</span><br><span class="line">			fmt.Println("server read client messages err:", err)</span><br><span class="line">			continue</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		// 如果读到数据长度为0 则用户退出</span><br><span class="line">		if n == 0 {</span><br><span class="line">			isLogout &lt;- true</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		// 如果用户发送了消息  则hasData为true</span><br><span class="line">		hasData &lt;- true</span><br><span class="line"></span><br><span class="line">		msg := string(buf[:n])</span><br><span class="line">		// 如果发送的是who 返回当前在线用户列表</span><br><span class="line">		if msg == "who" {</span><br><span class="line">			var onlinelist string</span><br><span class="line">			conn.Write([]byte("online user list:\n"))</span><br><span class="line">			for _, cli := range onlineMap {</span><br><span class="line">				onlinelist += fmt.Sprintf("name:%s\n", cli.Name)</span><br><span class="line">			}</span><br><span class="line">			conn.Write([]byte(onlinelist))</span><br><span class="line">			// 如果用户发送的消息是rename 则修改当前用户的名字</span><br><span class="line">		} else if len(msg) &gt;= 6 &amp;&amp; msg[:6] == "rename" {</span><br><span class="line">			cli.Name = strings.Split(msg, "|")[1]</span><br><span class="line">			conn.Write([]byte("rename success:\n"))</span><br><span class="line">		} else {</span><br><span class="line">			messages &lt;- makeMsg(cli, string(buf[:n]))</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func handleConn(conn net.Conn) {</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	// 获取用户ip</span><br><span class="line">	cliAddr := conn.RemoteAddr().String()</span><br><span class="line"></span><br><span class="line">	// 把用户信息保存到结构体</span><br><span class="line">	client := Client{</span><br><span class="line">		C:    make(chan string),</span><br><span class="line">		Name: cliAddr,</span><br><span class="line">		Addr: cliAddr,</span><br><span class="line">	}</span><br><span class="line">	// 把用户保存到map</span><br><span class="line">	onlineMap[cliAddr] = &amp;client</span><br><span class="line">	// 把用户上线的消息放到全局chan</span><br><span class="line">	messages &lt;- makeMsg(&amp;client, "上线了")</span><br><span class="line">	// 用户是否退出了</span><br><span class="line">	isLogout := make(chan bool)</span><br><span class="line">	// 用户是否发消息了</span><br><span class="line">	hasData := make(chan bool)</span><br><span class="line"></span><br><span class="line">	// 每创建新增一个用户  就对应创建一个协程用来发送消息</span><br><span class="line">	go writeMsgToClient(&amp;client, conn)</span><br><span class="line">	// 每创建新增一个用户  就对应创建一个协程用来接收用户发的消息</span><br><span class="line">	go readClientMsg(&amp;client, conn, isLogout, hasData)</span><br><span class="line"></span><br><span class="line">	for {</span><br><span class="line">		select {</span><br><span class="line">		case &lt;-isLogout:</span><br><span class="line">			// 如果isLogout中有值 把用户从onlineMap中删除 并广播用户下线</span><br><span class="line">			delete(onlineMap, client.Addr)</span><br><span class="line">			messages &lt;- makeMsg(&amp;client, "logout")</span><br><span class="line">			return</span><br><span class="line">		case &lt;-hasData:</span><br><span class="line">		case &lt;-time.After(time.Second * 15): // 15秒没有发送消息则超时</span><br><span class="line">			delete(onlineMap, client.Addr)</span><br><span class="line">			messages &lt;- makeMsg(&amp;client, "timeout")</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	// 创建监听</span><br><span class="line">	listener, err := net.Listen("tcp", ":8888")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("net.listen err", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	// 专门负责转发消息 有消息时 遍历所有在线用户 把消息转发到所有用户</span><br><span class="line">	go Manager()</span><br><span class="line"></span><br><span class="line">	for {</span><br><span class="line">		// 阻塞等待用户连接</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Println("listener.Accept() err", err)</span><br><span class="line">			// 连接出错则跳过这个连接</span><br><span class="line">			continue</span><br><span class="line">		}</span><br><span class="line">		go handleConn(conn)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现简单文件传输</title>
    <url>/2020/11/14/Golang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h3 id="简单文件传输"><a href="#简单文件传输" class="headerlink" title="简单文件传输"></a>简单文件传输</h3><p>文件传输分为客户端和服务端,通过下图的方式进行文件的传输<br><img src="http://files.codedog.link/blog/typecho/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="文件传输" title="文件传输"></p>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现:"></a>客户端实现:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"io"</span><br><span class="line">	"net"</span><br><span class="line">	"os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func sendFile(fp string, conn net.Conn) {</span><br><span class="line">	file, err := os.Open(fp)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("open file faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	buf := make([]byte, 1024*4)</span><br><span class="line">	for {</span><br><span class="line">		n, err := file.Read(buf)</span><br><span class="line">		if err != nil {</span><br><span class="line">			if err == io.EOF {</span><br><span class="line">				fmt.Println("文件发送完毕")</span><br><span class="line">				return</span><br><span class="line">			}</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line">		conn.Write(buf[:n])</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	// 获取文件路径</span><br><span class="line">	fmt.Println("请输入需要传输文件的路径：")</span><br><span class="line">	var filePath string</span><br><span class="line">	fmt.Scan(&amp;filePath)</span><br><span class="line"></span><br><span class="line">	fileInfo, err := os.Stat(filePath)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fileName := fileInfo.Name()</span><br><span class="line">	fileSize := fileInfo.Size()</span><br><span class="line">	fmt.Printf("fileName:%s\nfileSize:%d\n", fileName, fileSize)</span><br><span class="line"></span><br><span class="line">	// 连接服务器</span><br><span class="line">	conn, err := net.Dial("tcp", "127.0.0.1:8888")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("net.Dial() faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	// 发送文件名</span><br><span class="line">	_, err = conn.Write([]byte(fileName))</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("conn.Write() faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	buf := make([]byte, 4)</span><br><span class="line">	// 接收服务器返回</span><br><span class="line">	n, err := conn.Read(buf)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("conn.Read() faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	if "ok" == string(buf[:n]) {</span><br><span class="line">		sendFile(filePath, conn)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现:"></a>服务端实现:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"io"</span><br><span class="line">	"net"</span><br><span class="line">	"os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func recvFile(fileName string, conn net.Conn) {</span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("os.OpenFile() faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer file.Close()</span><br><span class="line">	buf := make([]byte, 1024*4)</span><br><span class="line">	for {</span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		if err != nil {</span><br><span class="line">			if err == io.EOF {</span><br><span class="line">				fmt.Println("文件接收完毕")</span><br><span class="line">				return</span><br><span class="line">			}</span><br><span class="line">			fmt.Println("conn.Read() faild")</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line">		if n == 0 {</span><br><span class="line">			fmt.Println("文件接收完毕")</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line">		file.Write(buf[:n])</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	listener, err := net.Listen("tcp", ":8888")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("net.Listen() faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer listener.Close()</span><br><span class="line">	conn, err := listener.Accept()</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("listener.Accept() faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	buf := make([]byte, 1024)</span><br><span class="line">	n, err := conn.Read(buf)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("conn.Read() faild")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	fileName := string(buf[:n])</span><br><span class="line">	conn.Write([]byte("ok"))</span><br><span class="line">	recvFile(fileName, conn)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go模板渲染</title>
    <url>/2020/11/14/Golang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h3 id="Template渲染"><a href="#Template渲染" class="headerlink" title="Template渲染"></a>Template渲染</h3><blockquote>
<p>Golang原生支持对Template的数据渲染(text/template)</p>
</blockquote>
<p>Go:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net/http"</span><br><span class="line">	"text/template"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 模板</span><br><span class="line"></span><br><span class="line">// Person 结构体</span><br><span class="line">type Person struct {</span><br><span class="line">	Name string `json:"name"`</span><br><span class="line">	Age  int    `json:"age"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func templateHandle(respWrite http.ResponseWriter, req *http.Request) {</span><br><span class="line">	// 准备渲染数据</span><br><span class="line">	p := Person{</span><br><span class="line">		Name: "张三",</span><br><span class="line">		Age:  20,</span><br><span class="line">	}</span><br><span class="line">	// 加载html文件</span><br><span class="line">	temp, err := template.ParseFiles("./go_dev/day10/example7/main/index.html")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("parse file err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	// 把数据渲染到模板</span><br><span class="line">	err = temp.Execute(respWrite, p)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("template Execute err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	http.HandleFunc("/", templateHandle)</span><br><span class="line">	err := http.ListenAndServe(":8888", nil)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("listen err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>index.html:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh-cn"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hi {{.Name}}&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Template-条件语句"><a href="#Template-条件语句" class="headerlink" title="Template 条件语句"></a>Template 条件语句</h3><ul>
<li>if判断:  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">            {{if gt .Age 18}}</span><br><span class="line">            &lt;p&gt;hello, old man, {{.Name}}&lt;/p&gt;</span><br><span class="line">            {{else}}</span><br><span class="line">            &lt;p&gt;hello,young man, {{.Name}}&lt;/p&gt;</span><br><span class="line">            {{end}}</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>
  常见操作符:<ul>
<li>not 非   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if not .condition}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>and 与   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if and .condition1 .condition2}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>or 或   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if or .condition1 .condition2}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>eq 等于   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if eq .var1 .var2}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>ne 不等于   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if ne .var1 .var2}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>lt 小于 (less than)   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if lt .var1 .var2}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>le 小于等于   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if le .var1 .var2}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>gt 大于  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if gt .var1 .var2}}&nbsp;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></li>
<li>ge 大于等于   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{if ge .var1 .var2}}&nbsp;</span><br><span class="line">{{end}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li>range循环<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> {{range .}}</span><br><span class="line">    {{if gt .Age 18}}</span><br><span class="line">    &lt;p&gt;hello, old man, {{.Name}}&lt;/p&gt;</span><br><span class="line">    {{else}}</span><br><span class="line">    &lt;p&gt;hello,young man, {{.Name}}&lt;/p&gt;</span><br><span class="line">    {{end}}</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>例子:</p>
</blockquote>
</li>
<li>main.go:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net/http"</span><br><span class="line">	"text/template"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct {</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var temp *template.Template</span><br><span class="line"></span><br><span class="line">// 模板-条件渲染</span><br><span class="line"></span><br><span class="line">func userInfo(respWrite http.ResponseWriter, req *http.Request) {</span><br><span class="line">	// 加载模板</span><br><span class="line">	temp, err := template.ParseFiles("./go_dev/day10/example8/main/index.html")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("load template file err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	// 准备渲染数据</span><br><span class="line">	var pArr []Person</span><br><span class="line"></span><br><span class="line">	p1 := Person{</span><br><span class="line">		Name: "张三",</span><br><span class="line">		Age:  18,</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	p2 := Person{</span><br><span class="line">		Name: "张四",</span><br><span class="line">		Age:  21,</span><br><span class="line">	}</span><br><span class="line">	pArr = append(pArr, p1)</span><br><span class="line">	pArr = append(pArr, p2)</span><br><span class="line">	// 把数据渲染到模板</span><br><span class="line">	err = temp.Execute(respWrite, pArr)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("template execute err:", err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	http.HandleFunc("/user", userInfo)</span><br><span class="line">	err := http.ListenAndServe(":8888", nil)</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("http listen err:", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li>index.html:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh-cn"&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 循环 range--&gt;</span><br><span class="line">    {{range .}}</span><br><span class="line">        &lt;h1&gt;hi {{.Name}}&lt;/h1&gt;</span><br><span class="line">        &lt;!-- 条件判断  --&gt;</span><br><span class="line">        {{if gt .Age 18}}</span><br><span class="line">            &lt;p&gt;Your age is {{.Age}} and you are an adult.&lt;/p&gt;</span><br><span class="line">        {{else}}</span><br><span class="line">            &lt;p&gt;Your age is {{.Age}} and you are a minor.&lt;/p&gt;</span><br><span class="line">        {{end}}</span><br><span class="line">    {{end}}</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go统一错误处理</title>
    <url>/2020/11/14/Golang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>main.go:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"go_dev/day11/example1/filelist"</span><br><span class="line">	"net/http"</span><br><span class="line">	"os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type appHandle func(http.ResponseWriter, *http.Request) error</span><br><span class="line"></span><br><span class="line">// 定义一个包装类型 对出错进行统一处理</span><br><span class="line">func appWrap(hand appHandle) func(http.ResponseWriter, *http.Request) {</span><br><span class="line"></span><br><span class="line">	return func(resp http.ResponseWriter, req *http.Request) {</span><br><span class="line">		// 对panic进行处理</span><br><span class="line">		defer func() {</span><br><span class="line">			r := recover()</span><br><span class="line">			if r != nil {</span><br><span class="line">				http.Error(resp, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)</span><br><span class="line">			}</span><br><span class="line">		}()</span><br><span class="line"></span><br><span class="line">		err := hand(resp, req)</span><br><span class="line">		if err != nil {</span><br><span class="line">			switch {</span><br><span class="line">			case os.IsNotExist(err):</span><br><span class="line">				http.Error(resp, http.StatusText(http.StatusNotFound), http.StatusNotFound)</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">	http.HandleFunc("/list/", appWrap(filelist.HandlerFile))</span><br><span class="line"></span><br><span class="line">	err := http.ListenAndServe(":8888", nil)</span><br><span class="line">	if err != nil {</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>handlerFile.go:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package filelist</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"io/ioutil"</span><br><span class="line">	"net/http"</span><br><span class="line">	"os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func HandlerFile(resp http.ResponseWriter, req *http.Request) error {</span><br><span class="line">	path := req.URL.Path[len("/list/"):]</span><br><span class="line">	fmt.Println("HandlerFile:", path)</span><br><span class="line">	file, err := os.Open(path)</span><br><span class="line">	if err != nil {</span><br><span class="line">		return err</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	all, err := ioutil.ReadAll(file)</span><br><span class="line">	if err != nil {</span><br><span class="line">		return err</span><br><span class="line">	}</span><br><span class="line">	resp.Write(all)</span><br><span class="line">	return nil</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的Socket编程</title>
    <url>/2020/11/14/Golang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h2><p>套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。</p>
<h2 id="Socket分类："><a href="#Socket分类：" class="headerlink" title="Socket分类："></a>Socket分类：</h2><p>为了满足不同的通信程序对通信质量和性能的要求，一般的网络系统提供了三种不同类型的套接字，以供用户在设计网络应用程序时根据不同的要求来选择。这三种套接为流式套接字（SOCK-STREAM）、数据报套接字（SOCK-DGRAM）和原始套接字（SOCK-RAW）。</p>
<h3 id="1-流式套接字-TCP"><a href="#1-流式套接字-TCP" class="headerlink" title="1.流式套接字(TCP)"></a>1.流式套接字(TCP)</h3><blockquote>
<p>它提供了一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在TCP/IP协议簇中，使用TCP协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</p>
</blockquote>
<h3 id="2-数据报套接字-UDP"><a href="#2-数据报套接字-UDP" class="headerlink" title="2.数据报套接字(UDP)"></a>2.数据报套接字(UDP)</h3><blockquote>
<p>它提供了一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在TCP/IP协议簇中，使用UDP协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</p>
</blockquote>
<h3 id="3-原始套接字-IP或者ICMP"><a href="#3-原始套接字-IP或者ICMP" class="headerlink" title="3.原始套接字(IP或者ICMP)"></a>3.原始套接字(IP或者ICMP)</h3><blockquote>
<p>该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。</p>
</blockquote>
<h2 id="Go-Socket编程"><a href="#Go-Socket编程" class="headerlink" title="Go Socket编程"></a>Go Socket编程</h2><p>Go提供net网络包实现基本的tcp/udp网络编程能力。使用net包非常简单。</p>
<h3 id="服务端实现思路："><a href="#服务端实现思路：" class="headerlink" title="服务端实现思路："></a>服务端实现思路：</h3><ul>
<li>首先启动一个监听器，声明传输协议与主机端口信息；</li>
<li>启动一个无限循环不断从监听器接收客户端连接；</li>
<li>为每个客户端连接创建一个处理协程，处理协程实现对客户端的响应。</li>
</ul>
<h3 id="客户端实现思路："><a href="#客户端实现思路：" class="headerlink" title="客户端实现思路："></a>客户端实现思路：</h3><ul>
<li>首先客户端拨号连接服务端，声明传输协议与服务端主机和端口信息；</li>
<li>准备一个读写缓冲的字节数组</li>
<li>启动一个无限循环不断从终端读取用户输入，通过缓冲字节数组发送给服务端并等待服务端响应。</li>
</ul>
<h2 id="服务端实现-Server-go"><a href="#服务端实现-Server-go" class="headerlink" title="服务端实现 Server.go:"></a>服务端实现 Server.go:</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net"</span><br><span class="line">	"strings"</span><br><span class="line">	"time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func handlerConn(conn net.Conn) {</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	// 拿到客户端地址</span><br><span class="line">	addr := conn.RemoteAddr().String()</span><br><span class="line">	fmt.Printf("[%s] connection success\n", addr)</span><br><span class="line"></span><br><span class="line">	buf := make([]byte, 1024)</span><br><span class="line">	for {</span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		if err != nil {</span><br><span class="line">			// 客户端主动关闭</span><br><span class="line">			if err.Error() == "EOF" {</span><br><span class="line">				fmt.Printf("[%s] exit\n", addr)</span><br><span class="line">				return</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			fmt.Printf("[%s] conn read err:%s\n", addr, err)</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line">		msg := string(buf[:n])</span><br><span class="line">		fmt.Printf("[%v] Received a message from [%s]:\n %s\n\n", time.Now().UTC(), addr, msg)</span><br><span class="line">		if "exit" == msg {</span><br><span class="line">			fmt.Printf("[%s] exit\n", addr)</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line">		conn.Write([]byte(strings.ToUpper(msg)))</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func server() {</span><br><span class="line">	listener, err := net.Listen("tcp", ":8888")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("listener err", err)</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer listener.Close()</span><br><span class="line"></span><br><span class="line">	for {</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Println("conn client err", err)</span><br><span class="line">			return</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		go handlerConn(conn)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	server()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">[2019-08-07 03:35:21.6288183 +0000 UTC] Received a message from [127.0.0.1:62777]:</span><br><span class="line"> hello</span><br><span class="line"></span><br><span class="line">[2019-08-07 03:35:28.3784244 +0000 UTC] Received a message from [127.0.0.1:62777]:</span><br><span class="line"> 你好呀</span><br><span class="line"></span><br><span class="line">[2019-08-07 03:35:35.9991891 +0000 UTC] Received a message from [127.0.0.1:62777]:</span><br><span class="line"> exit</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="客户端实现-Client-go"><a href="#客户端实现-Client-go" class="headerlink" title="客户端实现 Client.go:"></a>客户端实现 Client.go:</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"bufio"</span><br><span class="line">	"fmt"</span><br><span class="line">	"net"</span><br><span class="line">	"os"</span><br><span class="line">	"time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func received(conn net.Conn) {</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	buf := make([]byte, 1024)</span><br><span class="line">	addr := conn.RemoteAddr()</span><br><span class="line">	for {</span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		if err != nil {</span><br><span class="line">			fmt.Println("read err:", err)</span><br><span class="line">			continue</span><br><span class="line">		}</span><br><span class="line">		msg := string(buf[:n])</span><br><span class="line">		fmt.Printf("[%v] Received a message from [%s]:\n %s\n\n", time.Now().UTC(), addr, msg)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	conn, err := net.Dial("tcp", "127.0.0.1:8888")</span><br><span class="line">	if err != nil {</span><br><span class="line">		fmt.Println("[client]: Dial err")</span><br><span class="line">		return</span><br><span class="line">	}</span><br><span class="line">	defer conn.Close()</span><br><span class="line"></span><br><span class="line">	go received(conn)</span><br><span class="line"></span><br><span class="line">	scan := bufio.NewScanner(os.Stdin)</span><br><span class="line">	for scan.Scan() {</span><br><span class="line">		line := scan.Text()</span><br><span class="line">		conn.Write([]byte(line))</span><br><span class="line">		if "exit" == line {</span><br><span class="line">			break</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">---------------</span><br><span class="line">hello</span><br><span class="line">[2019-08-07 03:35:21.6395571 +0000 UTC] Received a message from [127.0.0.1:8888]:</span><br><span class="line"> HELLO</span><br><span class="line"></span><br><span class="line">你好呀</span><br><span class="line">[2019-08-07 03:35:28.3891645 +0000 UTC] Received a message from [127.0.0.1:8888]:</span><br><span class="line"> 你好呀</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Golang</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>多模块Maven项目统一修改版本号</title>
    <url>/2020/11/14/Java/Maven/%E5%A4%9A%E6%A8%A1%E5%9D%97Maven%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>在编写多Module的Maven项目时，如果Module很多，并且存在复杂层级，那么修改项目版本号将会是一个大工程，我们需要去每个Module中修改当前Module的版本号，以及它依赖的parent的版本号。</p>
<p>Maven中存在专门的一个用于修改Module版本号的插件，Versions Maven Plugin，网址为：<a href="http://www.mojohaus.org/versions-maven-plugin/%E3%80%82">http://www.mojohaus.org/versions-maven-plugin/。</a></p>
<h4 id="1-在顶级-Module-中添加插件"><a href="#1-在顶级-Module-中添加插件" class="headerlink" title="1.在顶级 Module 中添加插件"></a>1.在顶级 Module 中添加插件</h4><p>为了使用版本号修改的功能，需要现在顶级 Module 中添加插件，代码如下：</p>
<blockquote>
<p>在Spring Boot中的spring-boot-dependencies中的pluginManagement已经添加了该插件，所以这里没有配置插件的版本号。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;versions-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;generateBackupPoms&gt;false&lt;/generateBackupPoms&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这个插件中有一些配置，上述 ‘generateBackupPoms’ 配置的作用是在修改 pom 时是否对原文件进行备份，我们的项目一般都会使用 git 进行管理，我们可以关闭备份功能。</p>
</blockquote>
<h4 id="2-为顶级-Module-设置新版本"><a href="#2-为顶级-Module-设置新版本" class="headerlink" title="2.为顶级 Module 设置新版本"></a>2.为顶级 Module 设置新版本</h4><p>设置的方式有两种，一种是自己手动修改，另外一种是使用上述插件的命令，命令如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mvn versions:set -DnewVersion=0.1.2-SNATHOST</span><br></pre></td></tr></tbody></table></figure>
<p>该命令只会为顶级的 Module 修改版本号。</p>
<h4 id="3-更新所有子-Module-的版本"><a href="#3-更新所有子-Module-的版本" class="headerlink" title="3.更新所有子 Module 的版本"></a>3.更新所有子 Module 的版本</h4><p>更新方式很简单，只需要执行一条命令即可，命令如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mvn versions:update-child-modules</span><br></pre></td></tr></tbody></table></figure>
<p>在更新子 Module 的版本时需要注意，我们之前的项目的所有 Module 版本号需要统一，否则版本号会更新不全。</p>
<h4 id="4-更新顶级项目的parent版本"><a href="#4-更新顶级项目的parent版本" class="headerlink" title="4. 更新顶级项目的parent版本"></a>4. 更新顶级项目的parent版本</h4><p>在使用Spring Boot的多Module项目时，我们可能需要更新项目所依赖的Spring Boot版本。我们可以使用如下命令来进行更新。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mvn versions:update-parent</span><br></pre></td></tr></tbody></table></figure>
<p>输出的信息中包含</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[INFO] Updating parent from 2.1.7.RELEASE to 2.1.9.RELEASE</span><br></pre></td></tr></tbody></table></figure>
<p>这时顶级Module的parent会变更为</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.9.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>文章转载自：<a href="http://www.lavecoral.me/archives/213.html" title="1">http://www.lavecoral.me/archives/213.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpClient的使用</title>
    <url>/2020/11/14/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/HttpClient%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="HttpClient-4-x-API常用方法"><a href="#HttpClient-4-x-API常用方法" class="headerlink" title="HttpClient 4.x API常用方法"></a>HttpClient 4.x API常用方法</h1><hr>
<blockquote>
<p>HttpClient是由Apache HttpComponents™项目负责创建和维护专注于HTTP和相关协议的低级Java组件工具集。该项目在Apache Software Foundation（<a href="http://www.apache.org)下运行,是更大的开发人员和用户社区的一部分./">http://www.apache.org）下运行，是更大的开发人员和用户社区的一部分。</a></p>
</blockquote>
<h3 id="HttpClient的特性"><a href="#HttpClient的特性" class="headerlink" title="HttpClient的特性"></a>HttpClient的特性</h3><ul>
<li>基于标准、纯净的 Java 语言。实现了 HTTP 1.0 和 HTTP 1.1</li>
<li>以可扩展的面向对象的结构实现了 HTTP 全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</li>
<li>支持 HTTPS 协议。</li>
<li>通过 HTTP 代理建立透明的连接。</li>
<li>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</li>
<li>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos 认证方案。 </li>
<li>插件式的自定义认证方案。</li>
<li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li>
<li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li>
<li>自动处理 Set-Cookie 中的 Cookie。</li>
<li>插件式的自定义 Cookie 策略。</li>
<li>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</li>
<li>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</li>
<li>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</li>
<li>直接获取服务器发送的 response code 和 headers。</li>
<li>设置连接超时的能力。</li>
<li>实验性的支持 HTTP 1.1 response caching。</li>
<li>源代码基于 Apache License 可免费获取。</li>
</ul>
<h3 id="HttpClient-使用流程"><a href="#HttpClient-使用流程" class="headerlink" title="HttpClient 使用流程"></a>HttpClient 使用流程</h3><ol>
<li><p>创建<code>HttpClient</code>对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CloseableHttpClient httpClient = HttpClients.createDefault();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>创建请求方法实例,并制定请求<code>URL</code>。如果需要发送<code>GET</code>请求，创建<code>HttpGet</code>对象，如果需要发送<code>POST</code>请求，创建<code>HttpPost</code>对象</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Get:</span><br><span class="line">HttpGet httpGet = new HttpGet("http://apis.juhe.cn/ip/ipNew?ip=112.112.11.11&amp;key=56e8d1ce739a1016392097d58af41af4");</span><br><span class="line">Post:</span><br><span class="line">HttpPost httpPost = new HttpPost("http://apis.juhe.cn/ip/ipNew");</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>如果要发送请求参数，可调用<code>HttpGet</code>、<code>HttpPost</code>共同的<code>setParams(HttpParams params)</code>方法来添加请求参数；对于<code>HttpPost</code>对象而言，也可调用<code>setEntity(HttpEntity entity)</code>方法来设置请求参数</p>
<blockquote>
<p>HttpClient提供一个<code>UrlEncodedFormEntity()</code>类以方便Post请求传递参数,<code>UrlEncodedFormEntit</code>继承<code>StringEntity</code>类,它提供了四个构造函数</p>
<ul>
<li> <code>UrlEncodedFormEntity(List&lt;? extends NameValuePair&gt; parameters, String charset) </code></li>
<li> <code>UrlEncodedFormEntity(Iterable&lt;? extends NameValuePair&gt; parameters, Charset charset) </code> </li>
<li> <code>UrlEncodedFormEntity(List&lt;? extends NameValuePair&gt; parameters)</code></li>
<li> <code>UrlEncodedFormEntity(Iterable&lt;? extends NameValuePair&gt; parameters)</code></li>
</ul>
</blockquote>
</li>
<li><p>可以通过调用<code>HttpClient</code> 对象的<code>execute(HttpUriRequest request)</code>方法来发送请求，这个方法返回一个<code>HttpResponse</code></p>
</li>
<li><p>调用<code>HttpResponse</code>的<code>getAllHeaders()</code>、<code>getHeaders(String name)</code>等方法可获得服务器的响应头；调用<code>HttpResponer</code>的<code>getEntity</code>方法可获取<code>HttpEntity</code>对象,该对象包装了服务器的响应内容,可通过该对象获取服务器的响应内容</p>
</li>
<li><p>不管执行方法是否成功,都应该释放链接</p>
</li>
</ol>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><hr>
<blockquote>
<p>maven依赖如下:</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- Apache Http Begin --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fluent-hc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpmime&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Apache Http End --&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="创建GET请求"><a href="#创建GET请求" class="headerlink" title="创建GET请求:"></a>创建GET请求:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class MyTest {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        get();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static void get() {</span><br><span class="line">        // 创建 HttpClient 客户端</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        // 创建 HttpGet 请求</span><br><span class="line">        HttpGet httpGet = new HttpGet("http://localhost:8080/content/page?draw=1&amp;start=0&amp;length=10");</span><br><span class="line">        // 设置长连接</span><br><span class="line">        httpGet.setHeader("Connection", "keep-alive");</span><br><span class="line">        // 设置代理（模拟浏览器版本）</span><br><span class="line">        httpGet.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36");</span><br><span class="line">        // 设置 Cookie</span><br><span class="line">        httpGet.setHeader("Cookie", "UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4");</span><br><span class="line"></span><br><span class="line">        CloseableHttpResponse httpResponse = null;</span><br><span class="line">        try {</span><br><span class="line">            // 请求并获得响应结果</span><br><span class="line">            httpResponse = httpClient.execute(httpGet);</span><br><span class="line">            HttpEntity httpEntity = httpResponse.getEntity();</span><br><span class="line">            // 输出请求结果</span><br><span class="line">            System.out.println(EntityUtils.toString(httpEntity));</span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 无论如何必须关闭连接</span><br><span class="line">        finally {</span><br><span class="line">            if (httpResponse != null) {</span><br><span class="line">                try {</span><br><span class="line">                    httpResponse.close();</span><br><span class="line">                } catch (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            if (httpClient != null) {</span><br><span class="line">                try {</span><br><span class="line">                    httpClient.close();</span><br><span class="line">                } catch (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="创建POST请求"><a href="#创建POST请求" class="headerlink" title="创建POST请求:"></a>创建POST请求:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class MyTest {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        post();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static void post() {</span><br><span class="line">        // 创建 HttpClient 客户端</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        // 创建 HttpPost 请求</span><br><span class="line">        HttpPost httpPost = new HttpPost("http://localhost:8080/content/page");</span><br><span class="line">        // 设置长连接</span><br><span class="line">        httpPost.setHeader("Connection", "keep-alive");</span><br><span class="line">        // 设置代理（模拟浏览器版本）</span><br><span class="line">        httpPost.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36");</span><br><span class="line">        // 设置 Cookie</span><br><span class="line">        httpPost.setHeader("Cookie", "UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4");</span><br><span class="line"></span><br><span class="line">        // 创建 HttpPost 参数</span><br><span class="line">        List&lt;BasicNameValuePair&gt; params = new ArrayList&lt;BasicNameValuePair&gt;();</span><br><span class="line">        params.add(new BasicNameValuePair("draw", "1"));</span><br><span class="line">        params.add(new BasicNameValuePair("start", "0"));</span><br><span class="line">        params.add(new BasicNameValuePair("length", "10"));</span><br><span class="line"></span><br><span class="line">        CloseableHttpResponse httpResponse = null;</span><br><span class="line">        try {</span><br><span class="line">            // 设置 HttpPost 参数</span><br><span class="line">            httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8"));</span><br><span class="line">            httpResponse = httpClient.execute(httpPost);</span><br><span class="line">            HttpEntity httpEntity = httpResponse.getEntity();</span><br><span class="line">            // 输出请求结果</span><br><span class="line">            System.out.println(EntityUtils.toString(httpEntity));</span><br><span class="line">        } catch (UnsupportedEncodingException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } catch (ClientProtocolException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 无论如何必须关闭连接</span><br><span class="line">        finally {</span><br><span class="line">            try {</span><br><span class="line">                if (httpResponse != null) {</span><br><span class="line">                    httpResponse.close();</span><br><span class="line">                }</span><br><span class="line">            } catch (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                if (httpClient != null) {</span><br><span class="line">                    httpClient.close();</span><br><span class="line">                }</span><br><span class="line">            } catch (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="封装出的工具类"><a href="#封装出的工具类" class="headerlink" title="封装出的工具类:"></a>封装出的工具类:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line">import org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line">import org.apache.http.client.methods.HttpGet;</span><br><span class="line">import org.apache.http.client.methods.HttpPost;</span><br><span class="line">import org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line">import org.apache.http.impl.client.HttpClients;</span><br><span class="line">import org.apache.http.message.BasicNameValuePair;</span><br><span class="line">import org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class HttpClientUtils {</span><br><span class="line">    public static final String CONNECTION = "Connection";</span><br><span class="line">    public static final String USER_AGENT= "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36";</span><br><span class="line"></span><br><span class="line">    public static String doGet(String url,String cookie){</span><br><span class="line">        return createRequest(HttpGet.METHOD_NAME,url,cookie);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static String doGet(String url){</span><br><span class="line">        return createRequest(HttpGet.METHOD_NAME,url,null);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static String createRequest(String method, String url, String cookie, BasicNameValuePair ... basicNameValuePairs){</span><br><span class="line">        CloseableHttpClient closeableHttpClient = HttpClients.createDefault();</span><br><span class="line">        CloseableHttpResponse httpResponse = null;</span><br><span class="line">        String result = null;</span><br><span class="line">        try {</span><br><span class="line">            if (HttpGet.METHOD_NAME.equals(method)) {</span><br><span class="line">                HttpGet httpGet = new HttpGet(url);</span><br><span class="line">                httpGet.setHeader("Connection", CONNECTION);</span><br><span class="line">                httpGet.setHeader("User-Agent", USER_AGENT);</span><br><span class="line">                if (StringUtils.isNotBlank(cookie)) {</span><br><span class="line">                    httpGet.setHeader("Cookie", cookie);</span><br><span class="line">                }</span><br><span class="line">                httpResponse = closeableHttpClient.execute(httpGet);</span><br><span class="line">                result = EntityUtils.toString(httpResponse.getEntity());</span><br><span class="line">            } else if (HttpPost.METHOD_NAME.equals(method)) {</span><br><span class="line">                HttpPost httpPost = new HttpPost();</span><br><span class="line">                httpPost.setHeader("Connection", CONNECTION);</span><br><span class="line">                httpPost.setHeader("User-Agent", USER_AGENT);</span><br><span class="line">                if (StringUtils.isNotBlank(cookie)) {</span><br><span class="line">                    httpPost.setHeader("Cookie", cookie);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                httpPost.setEntity(new UrlEncodedFormEntity(Arrays.asList(basicNameValuePairs), "UTF-8"));</span><br><span class="line"></span><br><span class="line">                httpResponse = closeableHttpClient.execute(httpPost);</span><br><span class="line">                System.out.println(httpResponse);</span><br><span class="line">                result = EntityUtils.toString(httpResponse.getEntity());</span><br><span class="line">            }</span><br><span class="line">        }catch (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }finally {</span><br><span class="line">            if (httpResponse!=null){</span><br><span class="line">                try {</span><br><span class="line">                    httpResponse.close();</span><br><span class="line">                } catch (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            if (closeableHttpClient!=null) {</span><br><span class="line">                try {</span><br><span class="line">                    closeableHttpClient.close();</span><br><span class="line">                } catch (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>《重学MySQL》</title>
    <url>/2020/11/14/MySQL/%E9%87%8D%E5%AD%A6MySQL/%E9%87%8D%E5%AD%A6MySQL/</url>
    <content><![CDATA[<p><img src="http://files.codedog.link/blog/typecho/mysql.jpg" alt="MySQL"></p>
<a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家好，我是洛阳，欢迎来到我的博客，作为一位后端开发者，免不了要与数据库打交道，而<code>MySQL</code>相信也是大家最熟悉的数据库之一，今天起，博主就要带领大家(自己)从头再次学习一次<code>MySQL</code>，当然，学习之前你肯定要使用过<code>MySQL</code>或者其它关系型数据库，本文并非数据库入门文章，所有内容仅仅是博主按照自己这几年使用的经验以及博主自己想要了解、学习的方向进行编写，不会对基本的增删改查语法进行过多的解释，另外本博主并非大厂出身。也不是能“徒手撕源码”、“光脚造轮子”、“吊打面试官”的大佬，所以如果本文以及后续文章中出现不正确或者有误导性的言论，还请您指出，大家共同学习，共同进步！</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h6 id=""><a href="#" class="headerlink" title=""></a><a href="/2020/11/14/MySQL/%E9%87%8D%E5%AD%A6MySQL/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85MySQL/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85MySQL-%E4%B8%8A/" title="下载并安装MySQL(上)">下载并安装MySQL(上)</a></h6><h6 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="#">Post not found: MySQL/重学MySQL/下载并安装MySQL/下载并安装MySQL(下) 下载并安装MySQL(下)</a></h6><h6 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/2020/11/17/MySQL/%E9%87%8D%E5%AD%A6MySQL/%E5%90%AF%E5%8A%A8Mysql/MySQL%E7%9A%84%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8A%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/" title="MySQL的启动以及启动参数">MySQL的启动以及启动参数</a></h6>]]></content>
      <categories>
        <category>MySQL</category>
        <category>重学MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>重学MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4使用</title>
    <url>/2020/11/14/%E5%89%8D%E7%AB%AF/webpack/webpack4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<img src="/2020/11/14/%E5%89%8D%E7%AB%AF/webpack/webpack4%E4%BD%BF%E7%94%A8/webpack.jpg" class="">
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h4 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h4><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<h4 id="为什么使用它？"><a href="#为什么使用它？" class="headerlink" title="为什么使用它？"></a>为什么使用它？</h4><p>如果像以前开发时一个html文件可能会引用十几个js文件,而且顺序还不能乱，因为它们存在依赖关系，同时对于ES6+等新的语法，less, sass等CSS预处理都不能很好的解决……，此时就需要一个处理这些问题的工具。</p>
<p>Webpack就是为处理这些问题而生的，它就是把你的项目当成一个整体，通过一个入口主文件（如：index.js）,从这个文件开始找到你的项目所有的依赖文件并处理它们，最后打包成一个（或多个）浏览器可识别的JavaScript文件。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>首先新建一个空文件夹，用于创建项目，在终端中进入文件夹，如下我在桌面建了一个名为webpack-project的文件夹，使用终端进入文件夹后（如果对命令行不太熟悉，可参考我的博客：前端常用命令行），使用npm init命令创建一个package.json文件。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></tbody></table></figure>

<h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></tbody></table></figure>
<h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><ol>
<li>在目录中新建一个<code>index.html</code>文件</li>
<li>在目录中新建一个<code>src</code>用于存放源码,在<code>src</code>目录中新建一个js文件:<code>index.js</code></li>
<li>在<code>package.json</code>中的<code>"scripts"</code>内写入两条命令:<code>    "dev" : "webpack --mode development"</code>，<code>"prod" : "webpack --mode production"</code></li>
<li>整体目录结构:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- demo</span><br><span class="line">-- node_modules</span><br><span class="line">-- src</span><br><span class="line">---- index.js</span><br><span class="line">-- index.html</span><br><span class="line">-- package.json</span><br><span class="line">-- package-lock.json</span><br></pre></td></tr></tbody></table></figure></li>
<li>package.json中的内容:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "name": "webpackDemo",</span><br><span class="line">  "version": "1.0.0",</span><br><span class="line">  "description": "",</span><br><span class="line">  "main": "index.js",</span><br><span class="line">  "scripts": {</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">	"dev" : "webpack --mode development",</span><br><span class="line">	"prod" : "webpack --mode production"</span><br><span class="line">  },</span><br><span class="line">  "keywords": [],</span><br><span class="line">  "author": "",</span><br><span class="line">  "license": "ISC",</span><br><span class="line">  "devDependencies": {</span><br><span class="line">    "webpack": "^4.43.0",</span><br><span class="line">    "webpack-cli": "^3.3.11"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
运行命令，会在当前根目录下生成一个<code>dist</code>目录，里面放着打包好的文件:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure>
<h2 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h2></li>
</ol>
<h2 id="本地服务器-webpack-dev-server"><a href="#本地服务器-webpack-dev-server" class="headerlink" title="本地服务器 webpack-dev-server"></a>本地服务器 webpack-dev-server</h2><h2 id="加载css"><a href="#加载css" class="headerlink" title="加载css"></a>加载css</h2><h2 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm i -D bable-loader @babel/core @babel/preset-env</span><br></pre></td></tr></tbody></table></figure>

<h2 id="生成HTML"><a href="#生成HTML" class="headerlink" title="生成HTML"></a>生成HTML</h2><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件:"></a>安装插件:</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></tbody></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置:"></a>配置:</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在webpack.config.js中配置：</span><br><span class="line"></span><br><span class="line">const HtmlWebpackPlugin = require('html-webpack-plugin')</span><br><span class="line"></span><br><span class="line">module.exports = {</span><br><span class="line">    plugins: [</span><br><span class="line">		new HtmlWebpackPlugin({</span><br><span class="line">			template: './src/index.html',</span><br><span class="line">			filename: 'webpack.html',</span><br><span class="line">			minify: { // 压缩HTML文件</span><br><span class="line">				//是否对大小写敏感，默认false</span><br><span class="line">				// caseSensitive: true,</span><br><span class="line">				//是否简写boolean格式的属性如：disabled="disabled" 简写为disabled  默认false</span><br><span class="line">				collapseBooleanAttributes: true,</span><br><span class="line">				//是否去除空格，默认false</span><br><span class="line">				collapseWhitespace: true,</span><br><span class="line">				//是否压缩html里的css（使用clean-css进行的压缩） 默认值false；</span><br><span class="line">				minifyCSS: true,</span><br><span class="line">				//是否压缩html里的js（使用uglify-js进行的压缩）</span><br><span class="line">				minifyJS: true,</span><br><span class="line">				//Prevents the escaping of the values of attributes</span><br><span class="line">				// preventAttributesEscaping: true,</span><br><span class="line">				//是否移除属性的引号 默认false</span><br><span class="line">				// removeAttributeQuotes: true,</span><br><span class="line">				//是否移除注释 默认false</span><br><span class="line">				removeComments: true,</span><br><span class="line">				//从脚本和样式删除的注释 默认false</span><br><span class="line">				// removeCommentsFromCDATA: true,</span><br><span class="line">				//是否删除空属性，默认false</span><br><span class="line">				removeEmptyAttributes: true,</span><br><span class="line">				//  若开启此项，生成的html中没有 body 和 head，html也未闭合</span><br><span class="line">				// removeOptionalTags: false,</span><br><span class="line">				//删除多余的属性</span><br><span class="line">				// removeRedundantAttributes: true,</span><br><span class="line">				//删除script的类型属性，在h5下面script的type默认值：text/javascript 默认值false</span><br><span class="line">				// removeScriptTypeAttributes: true,</span><br><span class="line">				//删除style的类型属性， type="text/css" 同上</span><br><span class="line">				// removeStyleLinkTypeAttributes: true,</span><br><span class="line">				//使用短的文档类型，默认false</span><br><span class="line">				// useShortDoctype: true,</span><br><span class="line">			},</span><br><span class="line">			hash:true</span><br><span class="line">		})</span><br><span class="line">	]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="分离HTML中的CSS"><a href="#分离HTML中的CSS" class="headerlink" title="分离HTML中的CSS"></a>分离HTML中的CSS</h2><blockquote>
<p>webpacK中有两个插件可以实现这个需求</p>
</blockquote>
<h4 id="第一个插件-老版本"><a href="#第一个插件-老版本" class="headerlink" title="第一个插件(老版本)"></a>第一个插件(老版本)</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 安装：</span><br><span class="line">npm i -D extract-text-webpack-plugin@next</span><br><span class="line">// 在webpack.config.js中配置：</span><br><span class="line">const ExtractTextPlugin = require('extract-text-webpack-plugin');</span><br><span class="line">module.exports = {</span><br><span class="line">    module: {</span><br><span class="line">		rules: [</span><br><span class="line">			{</span><br><span class="line">				test: /\.css$/,</span><br><span class="line">				use: ExtractTextPlugin.extract({</span><br><span class="line">					fallback: 'style-loader',</span><br><span class="line">					use: 'css-loader'</span><br><span class="line">				})</span><br><span class="line">			}</span><br><span class="line">		],</span><br><span class="line">		plugins: [new ExtractTextPlugin('./css/[name].css')]</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="新插件"><a href="#新插件" class="headerlink" title="新插件"></a>新插件</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm i -D mini-css-extract-plugin</span><br><span class="line">// 在webpack.config.js中配置：</span><br><span class="line">const MiniCssExtractPlugin = require('mini-css-extract-plugin');</span><br><span class="line">module.exports = {</span><br><span class="line">    module: {</span><br><span class="line">		rules: [</span><br><span class="line">			{</span><br><span class="line">				test: /\.css$/,</span><br><span class="line">				use: [MiniCssExtractPlugin.loader,'css-loader']</span><br><span class="line">			}</span><br><span class="line">		],</span><br><span class="line">		plugins: [</span><br><span class="line">		    new MiniCssExtractPlugin({</span><br><span class="line">			    filename:'./css/[name].css'</span><br><span class="line">		    })</span><br><span class="line">		]</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="压缩CSS并优化结构"><a href="#压缩CSS并优化结构" class="headerlink" title="压缩CSS并优化结构"></a>压缩CSS并优化结构</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm i -D optimize-css-assets-webpack-plugin</span><br><span class="line">    </span><br><span class="line">// 在webpack.config.js中配置：</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')</span><br><span class="line"></span><br><span class="line">module.exports = {</span><br><span class="line">    module: {</span><br><span class="line">		plugins: [</span><br><span class="line">    		new OptimizeCssAssetsWebpackPlugin({</span><br><span class="line">    			assetNameRegExp: /\.css$/g,</span><br><span class="line">    			cssProcessor: require('cssnano'),</span><br><span class="line">    			cssProcessorPluginOptions: {</span><br><span class="line">    				preset: ['default', {</span><br><span class="line">    					discardComments: {</span><br><span class="line">    						removeAll: true</span><br><span class="line">    					}</span><br><span class="line">    				}]</span><br><span class="line">    			},</span><br><span class="line">    			canPrint: true</span><br><span class="line">    		})</span><br><span class="line">		]</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="拷贝静态文件"><a href="#拷贝静态文件" class="headerlink" title="拷贝静态文件"></a>拷贝静态文件</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm i -D copy-webpack-plugin</span><br><span class="line"></span><br><span class="line">// 在webpack.config.js中配置：</span><br><span class="line">const CopyWebpackPlugin = require('copy-webpack-plugin')</span><br><span class="line"></span><br><span class="line">module.exports = {</span><br><span class="line">    module: {</span><br><span class="line">		plugins: [</span><br><span class="line">    		new CopyWebpackPlugin([</span><br><span class="line">    			{</span><br><span class="line">    				// 静态资源路径</span><br><span class="line">    				from:__dirname+'/src/assets',</span><br><span class="line">    				// 要打包到的路径</span><br><span class="line">    				to:__dirname+'/dist/assets'</span><br><span class="line">    			}</span><br><span class="line">    		])</span><br><span class="line">		]</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="清除旧的打包文件"><a href="#清除旧的打包文件" class="headerlink" title="清除旧的打包文件"></a>清除旧的打包文件</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm i -D clean-webpack-plugin</span><br><span class="line"></span><br><span class="line">// 在webpack.config.js中配置：</span><br><span class="line">const { CleanWebpackPlugin } = require('clean-webpack-plugin')</span><br><span class="line">module.exports = {</span><br><span class="line">    module: {</span><br><span class="line">		plugins: [</span><br><span class="line">		    new CleanWebpackPlugin()</span><br><span class="line">		]</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="处理html中的内嵌图片"><a href="#处理html中的内嵌图片" class="headerlink" title="处理html中的内嵌图片"></a>处理html中的内嵌图片</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm i -D html-loader</span><br><span class="line"></span><br><span class="line">module.exports = {</span><br><span class="line">    module: {</span><br><span class="line">		rules   : [</span><br><span class="line">		    test:/\.(html)$/,</span><br><span class="line">				use:{</span><br><span class="line">					loader:'html-loader',</span><br><span class="line">					options:{</span><br><span class="line">						attrs:['img:src','img:data-src']</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		]</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker时区问题的坑</title>
    <url>/2020/11/14/%E8%BF%90%E7%BB%B4/Docker/Docker%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h3 id="关于docker中tomcat部署项目遇到时间不正确的问题"><a href="#关于docker中tomcat部署项目遇到时间不正确的问题" class="headerlink" title="关于docker中tomcat部署项目遇到时间不正确的问题"></a>关于docker中tomcat部署项目遇到时间不正确的问题</h3><p>在容器中执行<code>date</code>命令查看时间,发现容器中时间少了8个小时 执行以下命令，修改时间</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cd /etc/</span><br><span class="line">mv localtime localtime_bak</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></tbody></table></figure>
<p>因为docker中的java应用是从timezone中获取时间的，因此需要修改timezone</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">echo "Asia/Shanghai" &gt; /etc/timezone </span><br></pre></td></tr></tbody></table></figure>
<p>执行完这条语句，会发现docker 中java程序的时间也就一致了.</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建ngrok实现内网穿透</title>
    <url>/2020/11/14/%E8%BF%90%E7%BB%B4/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E6%90%AD%E5%BB%BAngrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司突然要做微信开发，需要做内网穿透,本人一开始使用过<code>www.ngrok.cc</code>,价格不贵,也很方便,不过自己比较喜欢折腾,于是自己查询资料，可以使用<code>ngrok</code>在云服务器上搭建来实现多客户端的内网穿透，配置上自己的域名还是很好的。</p>
<h1 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h1><p>个人有一台阿里云服务器<code>Ubuntu 16.04 1核1G</code>,一般使用绝对是没问题的,其他的linux发行版本也是没有问题的。</p>
<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><h1 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h1><p>这里用到的域名是<code>ngrok.codedog.link</code>,需要将<code>ngrok.codedog.link</code>和<code>*.ngrok.codedog.link</code>解析到该云服务器上。</p>
<blockquote>
<p>注：博主换过域名,以前用的是<code>codedog.link</code>,后来感觉有点搞自己,现在用自己名字重新注册了一个<code>luxiang.wiki</code></p>
</blockquote>
<h2 id="配置go语音环境"><a href="#配置go语音环境" class="headerlink" title="配置go语音环境"></a>配置go语音环境</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#下载</span><br><span class="line">wget https://storage.googleapis.com/golang/go1.9.1.linux-amd64.tar.gz</span><br><span class="line">#解压</span><br><span class="line">tar -zxvf go1.9.1.linux-amd64.tar.gz</span><br><span class="line">#移动到local目录</span><br><span class="line">mv go /usr/local</span><br></pre></td></tr></tbody></table></figure>
<h2 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#进入/usr/bin</span><br><span class="line">cd /usr/bin</span><br><span class="line">ln -s /usr/local/go/bin/go ./</span><br><span class="line">ln -s /usr/local/go/bin/godoc ./</span><br><span class="line">ln -s /usr/local/go/bin/gofmt ./</span><br></pre></td></tr></tbody></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go env</span><br><span class="line">GOARCH="amd64"</span><br><span class="line">GOBIN=""</span><br><span class="line">GOEXE=""</span><br><span class="line">GOHOSTARCH="amd64"</span><br><span class="line">GOHOSTOS="linux"</span><br><span class="line">GOOS="linux"</span><br><span class="line">GOPATH="/root/go"</span><br><span class="line">GORACE=""</span><br><span class="line">GOROOT="/usr/local/go"</span><br><span class="line">GOTOOLDIR="/usr/local/go/pkg/tool/linux_amd64"</span><br><span class="line">GCCGO="gccgo"</span><br><span class="line">CC="gcc"</span><br><span class="line">GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build025512091=/tmp/go-build -gno-record-gcc-switches"</span><br><span class="line">CXX="g++"</span><br><span class="line">CGO_ENABLED="1"</span><br><span class="line">CGO_CFLAGS="-g -O2"</span><br><span class="line">CGO_CPPFLAGS=""</span><br><span class="line">CGO_CXXFLAGS="-g -O2"</span><br><span class="line">CGO_FFLAGS="-g -O2"</span><br><span class="line">CGO_LDFLAGS="-g -O2"</span><br><span class="line">PKG_CONFIG="pkg-config"</span><br></pre></td></tr></tbody></table></figure>
<p>至此<code>go</code>语言环境配置完成。</p>
<h1 id="安装ngrok"><a href="#安装ngrok" class="headerlink" title="安装ngrok"></a>安装ngrok</h1><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/inconshreveable/ngrok.git</span><br></pre></td></tr></tbody></table></figure>

<h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 进入ngrok源码的目录</span><br><span class="line">cd ngrok</span><br><span class="line"># 创建保存自定义签名证书的文件夹  这里叫myssl</span><br><span class="line">mkdir myssl</span><br><span class="line"># 进入</span><br><span class="line">cd myssl</span><br><span class="line"># 设置域名，这里使用  ngrok.codedog.link</span><br><span class="line">export NGROK_DOMAIN="ngrok.codedog.link"</span><br><span class="line"># 然后依次执行以下命令即可</span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj "/CN=$NGROK_DOMAIN" -out device.csr</span><br><span class="line">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line"># 替换原来证书</span><br><span class="line">cp rootCA.pem ../assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt ../assets/server/tls/snakeoil.crt</span><br><span class="line">cp device.key ../assets/server/tls/snakeoil.key</span><br></pre></td></tr></tbody></table></figure>
<h2 id="编译服务端"><a href="#编译服务端" class="headerlink" title="编译服务端"></a>编译服务端</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 在ngrok目录执行</span><br><span class="line">export GOOS=linux</span><br><span class="line">export GOARCH=386</span><br><span class="line">make release-server</span><br></pre></td></tr></tbody></table></figure>

<h1 id="编译各大平台客户端"><a href="#编译各大平台客户端" class="headerlink" title="编译各大平台客户端"></a>编译各大平台客户端</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOOS=linux</span><br><span class="line">export GOARCH=386</span><br><span class="line">make release-client</span><br></pre></td></tr></tbody></table></figure>

<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOOS=darwin</span><br><span class="line">export GOARCH=amd64</span><br><span class="line">make release-client</span><br></pre></td></tr></tbody></table></figure>

<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOOS=windows</span><br><span class="line">export GOARCH=amd64</span><br><span class="line">make release-client</span><br></pre></td></tr></tbody></table></figure>
<h5 id="生成的可执行文件在-ngrok-bin-目录下，每个平台对应都有文件夹"><a href="#生成的可执行文件在-ngrok-bin-目录下，每个平台对应都有文件夹" class="headerlink" title="生成的可执行文件在 ngrok/bin 目录下，每个平台对应都有文件夹"></a>生成的可执行文件在 <code>ngrok/bin</code> 目录下，每个平台对应都有文件夹</h5><h1 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h1><p>由于服务器本身启动了<code>80</code>和<code>443</code>端口，因此这里改为<code>8000</code>和<code>444</code>端口，启动命令如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo ./ngrokd -domain="ngrok.codedog.link" -httpAddr=":8000" -httpsAddr=":444"</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://files.codedog.link/blog/typecho/1.png" alt="命令行" title="服务端启动效果"><br>上图可以看出使用了<code>4443</code>端口进行通讯</p>
<ul>
<li>注意：阿里云等有安全组的服务器,需要把端口加入白名单,一共需要开启白名单(<code>8000</code>,<code>444</code>,<code>4443</code>)</li>
</ul>
<h1 id="客户端配置文件"><a href="#客户端配置文件" class="headerlink" title="客户端配置文件"></a>客户端配置文件</h1><p>将上面生成的客户端可执行文件拷贝到需要内网穿透的设备上即可，这里直接说多域名和多TCP内网穿透配置文件，直接在客户端同级目录下创建<code>ngrok.cfg</code>配置文件，内容如下（只放了部分）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server_addr: ngrok.codedog.link:4443</span><br><span class="line">trust_host_root_certs: false</span><br><span class="line">tunnels:</span><br><span class="line"> weixin:</span><br><span class="line">  subdomain: weixin</span><br><span class="line">  proto:</span><br><span class="line">   http: 8002</span><br><span class="line"> about:</span><br><span class="line">  subdomain: about</span><br><span class="line">  proto:</span><br><span class="line">   http: 192.168.0.1:80</span><br><span class="line"> ssh:</span><br><span class="line">  remote_port: 2020</span><br><span class="line">  proto:</span><br><span class="line">   tcp: 22</span><br></pre></td></tr></tbody></table></figure>
<p>采用严格的单空格缩进，可以代理其他主机，直接跟端口默认是本主机，还要注意防火墙的配置。</p>
<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p>启动特定的转发:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./ngrok -config ngrok.cfg start weixin</span><br></pre></td></tr></tbody></table></figure>
<p>将所有配置转发:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./ngrok -config ngrok.cfg start-all</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>运维</category>
        <category>内网穿透</category>
        <category>ngrok</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot2.x整合redis</title>
    <url>/2020/11/14/Java/Spring%20Framework/Spring%20Boot/SpringBoot2-x%E6%95%B4%E5%90%88redis/</url>
    <content><![CDATA[<p>看了好多篇文章，再根据自己的理解进行的配置。</p>
<h3 id="一、Mevan相关配置"><a href="#一、Mevan相关配置" class="headerlink" title="一、Mevan相关配置"></a>一、Mevan相关配置</h3><h4 id="1-SpringBoot版本"><a href="#1-SpringBoot版本" class="headerlink" title="1.SpringBoot版本"></a>1.SpringBoot版本</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-引入spring-redis"><a href="#2-引入spring-redis" class="headerlink" title="2.引入spring-redis"></a>2.引入spring-redis</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="二、application-yml配置"><a href="#二、application-yml配置" class="headerlink" title="二、application.yml配置"></a>二、application.yml配置</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 省略数据库等其它配置...</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    database: 0</span><br><span class="line">    timeout: 1000s</span><br><span class="line">  cache:</span><br><span class="line">    redis:</span><br><span class="line">      time-to-live: 10000</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="三、redis配置类"><a href="#三、redis配置类" class="headerlink" title="三、redis配置类"></a>三、redis配置类</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package link.codedog.demo.configuration;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line">import com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.springframework.cache.CacheManager;</span><br><span class="line">import org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line">import org.springframework.cache.annotation.EnableCaching;</span><br><span class="line">import org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line">import org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line">import org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line">import java.time.Duration;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableCaching//启用缓存注解 用于开启@Cacheable、@CachePut、@CacheEvict</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport {</span><br><span class="line"></span><br><span class="line">    public static final String REDIS_KEY_DATABASE = "messaging";</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory){</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        // 配置连接工厂</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span><br><span class="line">        RedisSerializer jackson2JsonRedisSerializer = jsonSerializer();</span><br><span class="line">        RedisSerializer&lt;String&gt; stringRedisSerializer = new StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        // key采用String的序列化方式</span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        // hash的key也采用String的序列化方式</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        // value序列化方式采用jackson</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        // hash的value序列化方式采用jackson</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        return template;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory factory) {</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(this.getRedisCacheConfigurationWithTtl(-1)) // 默认策略，未配置的 key 会使用这个</span><br><span class="line">                .withInitialCacheConfigurations(this.getRedisCacheConfigurationMap()) // 指定 key 策略</span><br><span class="line">                .build();</span><br><span class="line">        return cacheManager;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public KeyGenerator simpleKeyGenerator() {</span><br><span class="line">        return (o, method, objects) -&gt; {</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">            stringBuilder.append(o.getClass().getSimpleName());</span><br><span class="line">            stringBuilder.append(".");</span><br><span class="line">            stringBuilder.append(method.getName());</span><br><span class="line">            stringBuilder.append("[");</span><br><span class="line">            for (Object obj : objects) {</span><br><span class="line">                stringBuilder.append(obj.toString());</span><br><span class="line">            }</span><br><span class="line">            stringBuilder.append("]");</span><br><span class="line"></span><br><span class="line">            return stringBuilder.toString();</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解决默认@Cacheable注解没有过期时间的问题 </span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, RedisCacheConfiguration&gt; getRedisCacheConfigurationMap() {</span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap = new HashMap&lt;&gt;();</span><br><span class="line">        redisCacheConfigurationMap.put(REDIS_KEY_DATABASE.concat(":ClueList"), this.getRedisCacheConfigurationWithTtl(3000));</span><br><span class="line"></span><br><span class="line">        return redisCacheConfigurationMap;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private RedisCacheConfiguration getRedisCacheConfigurationWithTtl(Integer seconds) {</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        // 配置序列化（解决乱码的问题）</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(seconds))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jsonSerializer()))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        return config;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private RedisSerializer jsonSerializer(){</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        //解决查询缓存转换异常的问题</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        return jackson2JsonRedisSerializer;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@Cacheable(value = "messaging:ClueList",keyGenerator = "simpleKeyGenerator",unless = "#result==null")</span><br><span class="line">public List&lt;Clue&gt; getList(){</span><br><span class="line">    List&lt;Clue&gt; all = clueRepository.findAll();</span><br><span class="line">    return all;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要指定 <code>key</code> 的过期时间，只要在<code>getRedisCacheConfigurationMap</code>方法中添加就可以。<br>然后只需要 <code>@Cacheable</code> 就可以把数据存入<code>redis</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@Cacheable(value = "messaging:ClueList",keyGenerator = "simpleKeyGenerator",unless = "#result==null") // 3000秒</span><br><span class="line">@Cacheable(value = "这里随便写个字符串", keyGenerator = "simpleKeyGenerator") // 不过期，未指定的key，使用默认策略</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Framework</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security的简单介绍</title>
    <url>/2020/11/14/Java/Spring%20Framework/Spring%20Security/Security%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="什么是Spring-Security"><a href="#什么是Spring-Security" class="headerlink" title="什么是Spring Security"></a>什么是Spring Security</h3><p>Spring Security 是一个安全框架，前身是 Acegi Security，能够为 Spring 企业应用系统提供声明式的安全访问控制。Spring Security 基于 <strong>Servlet 过滤器</strong>、<strong>IoC</strong> 和 <strong>AOP</strong>，为 Web 请求和方法调用提<a href="#Authencation">身份认证（Authencation）</a>和 <a href="#Authorization">用户授权（Authorization）</a>，避免了代码耦合，减少了大量重复代码工作。</p>
<h3 id="什么是身份认证（Authencation）"><a href="#什么是身份认证（Authencation）" class="headerlink" title="什么是身份认证（Authencation）"></a>什么是<a id="Authencation">身份认证（Authencation）</a></h3><p>身份认证指的是用户访问系统资源时，系统要求验证用户的身份信息，用户的身份合法才可以访问对应的资源。常见的身份认证一般要求用户提供用户名和密码，系统通过校验用户名和密码来完成认证过程。</p>
<h3 id="什么是用户授权（Authorization）"><a href="#什么是用户授权（Authorization）" class="headerlink" title="什么是用户授权（Authorization）"></a>什么是<a id="Authorization">用户授权（Authorization）</a></h3><p>当身份认证通过后，去访问系统的资源，系统会判断已经认证的用户是否拥有访问该资源的权限，只有拥有对应的权限，才能访问对应的资源，没有权限的资源则无法访问，这个过程叫做用户授权</p>
<blockquote>
<p>举个现实中的例子：我们现在远行都需要乘坐交通工具，而现在坐车都是实名制，我们坐车前都需要两样东西：<code>身份证</code>和<code>车票</code>。身份证是为了证明你确实是你，这就是 <strong>身份认证（Authencation）</strong>，而车票是为了证明你确实买了票，可以坐车，这就是 <strong>用户授权（Authorization）</strong>。这里可以看出，如果只有认证没有授权，认证就没有意义，如果没有认证，授权就无法赋予真正的用户。两个是同时存在的</p>
</blockquote>
<h3 id="RBAC模型"><a href="#RBAC模型" class="headerlink" title="RBAC模型"></a>RBAC模型</h3><p>RBAC（基于角色的权限控制）模型是为了解决系统中的权限管理问题，在用户和权限的基础上引入了角色这个概念，这样通过对角色的管理极大地降低了用户和权限之间的耦合，当你拥有某个角色以后，你自然就拥有了该角色所有的权限。如下图：<br><img src="http://files.codedog.link/blog/typecho/RBAC.png-suofang" alt="RBAC"></p>
<blockquote>
<p>关于RBAC模型的详细介绍请点击这里：<a href="http://www.woshipm.com/pd/1150093.html/comment-page-1">RBAC模型：基于用户-角色-权限控制的一些思考</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Framework</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security小试牛刀</title>
    <url>/2020/11/14/Java/Spring%20Framework/Spring%20Security/Spring%20Security%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前一篇介绍了 Spring Security 入门的基础准备。从今天开始我们来一步步窥探它是如何工作的。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>Spring Boot集成 Spring Security 只需要引入其对应的依赖即可</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>添加完成后声明一个index路由：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MainController {</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = {"", "/", "/index"})</span><br><span class="line">    public String main() {</span><br><span class="line">        return "index";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里我返回了一个首页<code>index</code>，完成后启动项目，访问：<code>http://127.0.0.1:8080</code>会自动跳转到一个登陆页面<code>http://127.0.0.1:8080/login</code>如下：<br><img src="http://files.codedog.link/blog/typecho/loginpage.png-suofang" alt="登陆页面"></p>
<p>这里是因为我们项目中引入了Spring Security以后，自动装配了Spring Security的环境，Spring Security的默认配置是要求经过认证成功后才可以访问到URL对应的资源，Spring Security的默认用户名是：<code>user</code>密码则是一串<code>uuid</code>字符串，输出在控制台里，仔细看一下下图，你可以发现该随机密码是由<code>UserDetailsServiceAutoConfiguration</code>配置生成的：<br><img src="http://files.codedog.link/blog/typecho/console.png-suofang" alt="控制台输出"></p>
<h3 id="UserDetailsServiceAutoConfiguration"><a href="#UserDetailsServiceAutoConfiguration" class="headerlink" title="UserDetailsServiceAutoConfiguration"></a>UserDetailsServiceAutoConfiguration</h3><p><code>UserDetailsServiceAutoConfiguration</code>全包名为：<code>org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration</code><br>源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2012-2019 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the "License");</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      https://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package org.springframework.boot.autoconfigure.security.servlet;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.logging.Log;</span><br><span class="line">import org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.ObjectProvider;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.SecurityProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.Lazy;</span><br><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line">import org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line">import org.springframework.security.config.annotation.ObjectPostProcessor;</span><br><span class="line">import org.springframework.security.core.userdetails.User;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line">import org.springframework.security.provisioning.InMemoryUserDetailsManager;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * {@link EnableAutoConfiguration Auto-configuration} for a Spring Security in-memory</span><br><span class="line"> * {@link AuthenticationManager}. Adds an {@link InMemoryUserDetailsManager} with a</span><br><span class="line"> * default user and generated password. This can be disabled by providing a bean of type</span><br><span class="line"> * {@link AuthenticationManager}, {@link AuthenticationProvider} or</span><br><span class="line"> * {@link UserDetailsService}.</span><br><span class="line"> *</span><br><span class="line"> * @author Dave Syer</span><br><span class="line"> * @author Rob Winch</span><br><span class="line"> * @author Madhura Bhave</span><br><span class="line"> * @since 2.0.0</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(AuthenticationManager.class)</span><br><span class="line">@ConditionalOnBean(ObjectPostProcessor.class)</span><br><span class="line">@ConditionalOnMissingBean({ AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class })</span><br><span class="line">public class UserDetailsServiceAutoConfiguration {</span><br><span class="line"></span><br><span class="line">	private static final String NOOP_PASSWORD_PREFIX = "{noop}";</span><br><span class="line"></span><br><span class="line">	private static final Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile("^\\{.+}.*$");</span><br><span class="line"></span><br><span class="line">	private static final Log logger = LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean(</span><br><span class="line">			type = "org.springframework.security.oauth2.client.registration.ClientRegistrationRepository")</span><br><span class="line">	@Lazy</span><br><span class="line">	public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,</span><br><span class="line">			ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder) {</span><br><span class="line">		SecurityProperties.User user = properties.getUser();</span><br><span class="line">		List&lt;String&gt; roles = user.getRoles();</span><br><span class="line">		return new InMemoryUserDetailsManager(</span><br><span class="line">				User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))</span><br><span class="line">						.roles(StringUtils.toStringArray(roles)).build());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) {</span><br><span class="line">		String password = user.getPassword();</span><br><span class="line">		if (user.isPasswordGenerated()) {</span><br><span class="line">			logger.info(String.format("%n%nUsing generated security password: %s%n", user.getPassword()));</span><br><span class="line">		}</span><br><span class="line">		if (encoder != null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) {</span><br><span class="line">			return password;</span><br><span class="line">		}</span><br><span class="line">		return NOOP_PASSWORD_PREFIX + password;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>关于几个注解的解释：</p>
</blockquote>
<ul>
<li><code>@ConditionalOnBean</code> 当给定的在bean存在时,则实例化当前Bean</li>
<li><code>@ConditionalOnMissingBean</code> 当给定的在bean不存在时,则实例化当前Bean</li>
<li><code>@ConditionalOnClass</code>  当给定的类名在类路径上存在，则实例化当前Bean</li>
<li><code>@ConditionalOnMissingClass</code> 当给定的类名在类路径上不存在，则实例化当前Bean</li>
</ul>
<p>从几个<code>@Conditional</code>注解我们可以看出<code>UserDetailsServiceAutoConfiguration</code>这个类在类路径下存在<code>AuthenticationManager</code>、在<code>Spring</code>容器中存在Bean<code>ObjectPostProcessor</code>并且不存在Bean <code>AuthenticationManager</code>, <code>AuthenticationProvider</code>, <code>UserDetailsService</code>的情况下才会生效；<br>该类初始化了一个名为<code>inMemoryUserDetailsManager</code>的基于内存的用户管理器，并且调用<code>getOrDeducePassword()</code>为我们生成了一个随机密码，<code>SecurityProperties.User user = properties.getUser();</code>这就是我们上面项目启动时，默认加载的用户：<code>user</code></p>
<h1 id="InMemoryUserDetailsManager"><a href="#InMemoryUserDetailsManager" class="headerlink" title="InMemoryUserDetailsManager"></a>InMemoryUserDetailsManager</h1><p>可以看出上面的<code>UserDetailsServiceAutoConfiguration</code>中初始化了一个名为<code>inMemoryUserDetailsManager</code>的类，全包名为：<code>org.springframework.security.provisioning.InMemoryUserDetailsManager</code>,其源码为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2002-2016 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the "License");</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      https://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line">package org.springframework.security.provisioning;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.logging.Log;</span><br><span class="line">import org.apache.commons.logging.LogFactory;</span><br><span class="line">import org.springframework.security.access.AccessDeniedException;</span><br><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line">import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line">import org.springframework.security.core.Authentication;</span><br><span class="line">import org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line">import org.springframework.security.core.userdetails.User;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsPasswordService;</span><br><span class="line">import org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line">import org.springframework.security.core.userdetails.memory.UserAttribute;</span><br><span class="line">import org.springframework.security.core.userdetails.memory.UserAttributeEditor;</span><br><span class="line">import org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Non-persistent implementation of {@code UserDetailsManager} which is backed by an</span><br><span class="line"> * in-memory map.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Mainly intended for testing and demonstration purposes, where a full blown persistent</span><br><span class="line"> * system isn't required.</span><br><span class="line"> *</span><br><span class="line"> * @author Luke Taylor</span><br><span class="line"> * @since 3.1</span><br><span class="line"> */</span><br><span class="line">public class InMemoryUserDetailsManager implements UserDetailsManager,</span><br><span class="line">		UserDetailsPasswordService {</span><br><span class="line">	protected final Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	private final Map&lt;String, MutableUserDetails&gt; users = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">	public InMemoryUserDetailsManager() {</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public InMemoryUserDetailsManager(Collection&lt;UserDetails&gt; users) {</span><br><span class="line">		for (UserDetails user : users) {</span><br><span class="line">			createUser(user);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public InMemoryUserDetailsManager(UserDetails... users) {</span><br><span class="line">		for (UserDetails user : users) {</span><br><span class="line">			createUser(user);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public InMemoryUserDetailsManager(Properties users) {</span><br><span class="line">		Enumeration&lt;?&gt; names = users.propertyNames();</span><br><span class="line">		UserAttributeEditor editor = new UserAttributeEditor();</span><br><span class="line"></span><br><span class="line">		while (names.hasMoreElements()) {</span><br><span class="line">			String name = (String) names.nextElement();</span><br><span class="line">			editor.setAsText(users.getProperty(name));</span><br><span class="line">			UserAttribute attr = (UserAttribute) editor.getValue();</span><br><span class="line">			UserDetails user = new User(name, attr.getPassword(), attr.isEnabled(), true,</span><br><span class="line">					true, true, attr.getAuthorities());</span><br><span class="line">			createUser(user);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public void createUser(UserDetails user) {</span><br><span class="line">		Assert.isTrue(!userExists(user.getUsername()), "user should not exist");</span><br><span class="line"></span><br><span class="line">		users.put(user.getUsername().toLowerCase(), new MutableUser(user));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public void deleteUser(String username) {</span><br><span class="line">		users.remove(username.toLowerCase());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public void updateUser(UserDetails user) {</span><br><span class="line">		Assert.isTrue(userExists(user.getUsername()), "user should exist");</span><br><span class="line"></span><br><span class="line">		users.put(user.getUsername().toLowerCase(), new MutableUser(user));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public boolean userExists(String username) {</span><br><span class="line">		return users.containsKey(username.toLowerCase());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public void changePassword(String oldPassword, String newPassword) {</span><br><span class="line">		Authentication currentUser = SecurityContextHolder.getContext()</span><br><span class="line">				.getAuthentication();</span><br><span class="line"></span><br><span class="line">		if (currentUser == null) {</span><br><span class="line">			// This would indicate bad coding somewhere</span><br><span class="line">			throw new AccessDeniedException(</span><br><span class="line">					"Can't change password as no Authentication object found in context "</span><br><span class="line">							+ "for current user.");</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		String username = currentUser.getName();</span><br><span class="line"></span><br><span class="line">		logger.debug("Changing password for user '" + username + "'");</span><br><span class="line"></span><br><span class="line">		// If an authentication manager has been set, re-authenticate the user with the</span><br><span class="line">		// supplied password.</span><br><span class="line">		if (authenticationManager != null) {</span><br><span class="line">			logger.debug("Reauthenticating user '" + username</span><br><span class="line">					+ "' for password change request.");</span><br><span class="line"></span><br><span class="line">			authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(</span><br><span class="line">					username, oldPassword));</span><br><span class="line">		}</span><br><span class="line">		else {</span><br><span class="line">			logger.debug("No authentication manager set. Password won't be re-checked.");</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		MutableUserDetails user = users.get(username);</span><br><span class="line"></span><br><span class="line">		if (user == null) {</span><br><span class="line">			throw new IllegalStateException("Current user doesn't exist in database.");</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		user.setPassword(newPassword);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public UserDetails updatePassword(UserDetails user, String newPassword) {</span><br><span class="line">		String username = user.getUsername();</span><br><span class="line">		MutableUserDetails mutableUser = this.users.get(username.toLowerCase());</span><br><span class="line">		mutableUser.setPassword(newPassword);</span><br><span class="line">		return mutableUser;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public UserDetails loadUserByUsername(String username)</span><br><span class="line">			throws UsernameNotFoundException {</span><br><span class="line">		UserDetails user = users.get(username.toLowerCase());</span><br><span class="line"></span><br><span class="line">		if (user == null) {</span><br><span class="line">			throw new UsernameNotFoundException(username);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		return new User(user.getUsername(), user.getPassword(), user.isEnabled(),</span><br><span class="line">				user.isAccountNonExpired(), user.isCredentialsNonExpired(),</span><br><span class="line">				user.isAccountNonLocked(), user.getAuthorities());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	public void setAuthenticationManager(AuthenticationManager authenticationManager) {</span><br><span class="line">		this.authenticationManager = authenticationManager;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>从该类中我们可以看出，其中的几个方法，其作用就是对用户(<code>UserDetails</code>)的增删改查：</p>
<ul>
<li><code>createUser(UserDetails user)</code>创建<code>UserDetails</code></li>
<li><code>updateUser(UserDetails user)</code>更新<code>UserDetails</code></li>
<li><code>deleteUser(String username)</code>根据<code>username</code>删除<code>UserDetails</code></li>
<li><code>userExists(String username)</code>根据<code>username</code>检查系统中是否存在对应的<code>UserDetails</code></li>
<li><code>changePassword(String oldPassword, String newPassword)</code>修改密码</li>
<li><code>loadUserByUsername(String username)</code>通过用户名获得对应的<code>UserDetails</code></li>
</ul>
<p>该类还实现了<code>UserDetailsManager</code>和<code>UserDetailsPasswordService</code>接口，而<code>UserDetailsManager</code>类又继承了<code>UserDetailsService</code>接口，这几个类的关系如下图：<br><img src="http://files.codedog.link/blog/typecho/UserDetailsService.png" alt="UserDetailsServiceAutoConfiguration结构"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章简单的对Spring Security进行了一些解读，其中简单介绍了几个相关的类，相信你已经对在Spring Security中如何加载用户信息有所掌握了，后面我们会由浅入深慢慢解读Spring Security。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Framework</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈IOC</title>
    <url>/2020/11/13/Java/Spring%20Framework/%E7%90%86%E8%AE%BA/%E6%B5%85%E8%B0%88IOC/</url>
    <content><![CDATA[<h2 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h2><p>IOC（Inversion Of Control，控制倒转），是spring的核心，贯穿始终，所谓IOC，对spring来说，就是由spring来负责对象的生命周期和对象间的关系。所有的类都会在spring容器中登记，告诉spring你是个什么，你需要什么，然后spring会在系统运行到适当的时候，把你需要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制。也就是说控制对象生命周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有的对象都被spring控制，所以这叫控制反转。</p>
<a id="more"></a>

<h2 id="IOC的主要作用是什么？"><a href="#IOC的主要作用是什么？" class="headerlink" title="IOC的主要作用是什么？"></a>IOC的主要作用是什么？</h2><p>IOC理论提出的观点大体是：借助于“第三方”实现具有依赖关系的对象之间的解耦，那么问题来了，什么是解耦呢？</p>
<h2 id="扩充话题"><a href="#扩充话题" class="headerlink" title="扩充话题"></a>扩充话题</h2><p>解耦通俗地说就是两个东西原来相互影响，现在让他们独立发展，核心思想还是最小职责，每个地方都只做一件事，只要一个地方负责了多项事情，就存在解耦的可能。在系统每个层次都可以体现解耦的思想，比如在架构层面把存储和业务逻辑解耦，把动态页面和静态页面解耦，在模块层把业务模块和统计模块解耦，在代码层把多个功能解耦等等。解耦的思想很好，但是没必要为了解耦而解耦，还是要从业务需求以及系统定位出发，满足一段时间内系统发展的需求即可。简单通俗的理解就是：电脑拔掉键盘鼠标显示器依然可以运行，这就是解耦</p>
<h2 id="什么是控制反转？"><a href="#什么是控制反转？" class="headerlink" title="什么是控制反转？"></a>什么是控制反转？</h2><p>就相当于,假如有a和b两个对象，在没有控制反转之前,a依赖于b，那么b对象在a初始化或者运行到某一处的时候，必须主动的去创建b对象或者使用已经创建好的b对象，无论是创建还是使用,控制权都在a手上；而通过控制反转之后，a和b之间就是去了直接的联系,a和b都交由“第三方”管理,当对象a需要对象b的时候,“第三方”会主动创建或把已存在的对象b注入到a需要的地方。其实通过这个举例可以很明显的就看出来，对象a获得对象b的过程,由主动行为变成了被动行为，控制权颠倒过来了，这就是“控制反转”这个 名称的由来</p>
<h2 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h2><p>依赖注入让bean与bean之间以配置文件组织在一起,而不是通过硬编码的方式耦合在一起，依赖注入是对控制反转的具体实现，从代码曾对两个依赖的“对象”进行解耦</p>
<h2 id="IOC可以给我们带来什么好处？"><a href="#IOC可以给我们带来什么好处？" class="headerlink" title="IOC可以给我们带来什么好处？"></a>IOC可以给我们带来什么好处？</h2><p>第一：资源集中管理，实现资源的可配置和易管理<br>第二：降低了使用资源双方的以来程度,也就是所谓的解耦</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Framework</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中使用Docker部署项目</title>
    <url>/2020/11/14/Java/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IntelliJ%20IDEA/IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="一、配置Docker并使用IDEA新建一个Spring-Boot项目"><a href="#一、配置Docker并使用IDEA新建一个Spring-Boot项目" class="headerlink" title="一、配置Docker并使用IDEA新建一个Spring Boot项目"></a>一、配置Docker并使用IDEA新建一个Spring Boot项目</h2><ul>
<li>配置Docker：<br><code>vim /lib/systemd/system/docker.service</code>,在<code>ExecStart</code>的行尾加上<code>-H tcp://0.0.0.0:2375</code>，如果服务器有安全组或者防火墙，记得把端口<code>2375</code>放行</li>
</ul>
<p><img src="http://files.codedog.link/blog/typecho/docker-setting.png" alt="docker,2375"></p>
<p><img src="http://files.codedog.link/blog/typecho/docker-ExecStart.png" alt="docker,2375"></p>
<ul>
<li>创建项目Spring Boot （自行创建）</li>
</ul>
<h2 id="二、指定Dockerfile"><a href="#二、指定Dockerfile" class="headerlink" title="二、指定Dockerfile"></a>二、指定Dockerfile</h2><ul>
<li>在项目<code>main</code>目录中新建一个目录,名字随缘，我这里就叫:<code>docker</code></li>
<li>新建的目录中放<code>Dockerfile</code></li>
<li><img src="http://files.codedog.link/blog/typecho/idea-main-docker-Dockerfile.png-suofang" alt="docker,Dockerfile"></li>
</ul>
<h2 id="三、修改项目中的pom-xml"><a href="#三、修改项目中的pom-xml" class="headerlink" title="三、修改项目中的pom.xml"></a>三、修改项目中的<code>pom.xml</code></h2><p>修改<code>pom.xml</code>在其<code>build&gt;plugins</code>节点下插入新的配置:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;!--这里是创建项目适合自动生成的打包插件--&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 下面是新加的 --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;!-- IP--&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.1.48:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;!-- Dockerfile文件位置--&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;</span><br><span class="line">                &lt;!-- 镜像名称以及版本号--&gt;</span><br><span class="line">                &lt;imageName&gt;${project.name}:${project.version}&lt;/imageName&gt;</span><br><span class="line">                &lt;!-- 复制jar到docker镜像的指定位置--&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;${project.build.directory}&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="四、打包运行"><a href="#四、打包运行" class="headerlink" title="四、打包运行"></a>四、打包运行</h2><ul>
<li><code>mvn clear</code>:</li>
<li><code>mvn pacage</code>或<code>mvn install</code>:</li>
<li><code>Plugins&gt;docker&gt;docker:build</code></li>
</ul>
<p><img src="http://files.codedog.link/blog/typecho/docker-build.png" alt="docker,Dockerfile"></p>
<blockquote>
<p>上面四步执行完以后，服务器上已经生成一个基于创建项目的镜像了，剩下的就是运行创建的镜像</p>
</blockquote>
<ul>
<li>运行：</li>
</ul>
<p><img src="http://files.codedog.link/blog/typecho/docker-run-1.png" alt="docker,Dockerfile"><br><img src="http://files.codedog.link/blog/typecho/docker-run-2.png" alt="docker,Dockerfile"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>开发工具</category>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>《重学MySQL》下载并安装Mysql(上)</title>
    <url>/2020/11/14/MySQL/%E9%87%8D%E5%AD%A6MySQL/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85MySQL/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85MySQL-%E4%B8%8A/</url>
    <content><![CDATA[<p><img src="http://files.codedog.link/blog/typecho/mysql.jpg" alt="MySQL"></p>
<a id="more"></a>


<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。</p>
<blockquote>
<p>上面这段话是博主百度百科复制来的，知道它并没有什么用，但是如果你不知道的话，最好百度了解一下，毕竟保不准有的面试官会问：“关系型数据库与非关系型数据库NoSql有什么区别？”（博主答：“我不懂! <span class="github-emoji"><span>😳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f633.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f633.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f633.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>”）</p>
</blockquote>
<h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><p>MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。<br>MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。<br>MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。</p>
<h3 id="MySQL优势"><a href="#MySQL优势" class="headerlink" title="MySQL优势"></a>MySQL优势</h3><p>由于 MySQL 数据库体积小、速度快、总体拥有成本低、开放源代码，其有着广泛的应用，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，因此搭配 PHP 和 Apache 服务器可组成良好的开发环境。</p>
<blockquote>
<p>总结来说就是：免费、开源、跨平台、性能好，活好还不要钱，谁不喜欢呢<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</blockquote>
<h3 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载MySQL</h3><p>首先我们打开<a href="https://www.mysql.com/">MySQL官网</a><code>https://www.mysql.com/</code>,在官网的首页有一个大大的<code>DOWNLOADS</code>，如下图:<br><img src="http://files.codedog.link/blog/typecho/MySQL.png" alt="MySQL.png"></p>
<p>点击后会跳转到下图所示的页面，直接拉到页面底部点击<a href="https://dev.mysql.com/downloads/">MySQL Community (GPL) Downloads »</a><br><img src="http://files.codedog.link/blog/typecho/MySQL-MySQL-Downloads.png" alt="下载"></p>
<p>接着会跳转到分类下载页面,常用的链接我给做了标注(“其实其它的部分没用过，部分不认识”)，如果你是<code>Windows</code>系统，直接点击<a href="https://dev.mysql.com/downloads/windows/">MySQL Installer for Windows</a>即可，如果是<code>Linux</code>可以按照你的<code>Linux</code>发行版本点击<a href="https://dev.mysql.com/downloads/repo/yum/">MySQL Yum Repository</a>或者<a href="https://dev.mysql.com/downloads/repo/apt/">MySQL APT Repository</a>进行安装</p>
<blockquote>
<p>不知道你们发现没有，上面两段话中所有带下划线的文字都可以点击，并且会直接跳转到文字描述的页面 <span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</blockquote>
<p><img src="http://files.codedog.link/blog/typecho/MySQL-MySQL-Community-Downloads-a.png" alt="下载"><br>点击完对应的链接就到了选择<code>MySQL</code>版本的页面啦，可以按照需求进行选择下载安装包,这里我会进行<code>Windows</code>和<code>Ubuntu 18</code>下的安装演示(“没用过MacOS,需要的话也可以自行百度看一下”)，当前默认下载的版本是<code>MySQL 8.0</code>你也可以点击右上角的<code>Looking for previous GA versions?</code>进行版本选择</p>
<p><img src="http://files.codedog.link/blog/typecho/MySQL-Download-MySQL-Installer.png" alt="Windows"></p>
<p>接下来点击<code>No thanks, just start my download.</code>就可以进行下载啦，当然你也可以选择登录后再下载<br><img src="http://files.codedog.link/blog/typecho/MySQL-Begin-Your-Download.png" alt="No thanks, just start my download."></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>重学MySQL</category>
        <category>下载并安装MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>重学MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《重学MySQL》下载并安装MySQL(下)</title>
    <url>/2020/11/16/MySQL/%E9%87%8D%E5%AD%A6MySQL/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85MySQL/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85MySQL-%E4%B8%8B/</url>
    <content><![CDATA[<p><img src="http://files.codedog.link/blog/typecho/mysql.jpg" alt="MySQL"></p>
<a id="more"></a>

<blockquote>
<p>废话一下，为什么下载和安装还要分两章写？因为博主只在晚上写博客，而自己的语言组织能力的确太差了，来来回回写，来来回回改，再加上调整配图，写完一篇洗个澡也差不多要睡觉了 </p>
</blockquote>
<h3 id="Windows下安装MySQL"><a href="#Windows下安装MySQL" class="headerlink" title="Windows下安装MySQL"></a>Windows下安装MySQL</h3><p>接下来进行Windows下MySQL的安装，在这之前请确保你已经下载了MySQL安装包，如果没有安装包，可以参考上一篇文章下载哦<br>双击运行下载的MySQL Installer，然后按照下图顺序即可（其实就是一路next<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）<br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-1.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-2.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-3.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-4.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-5.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-6.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-7.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-8.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-9.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-10.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-11.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-12.png" alt="MySQL-Installer"><br><img src="http://files.codedog.link/blog/typecho/MySQL-Installer-13.png" alt="MySQL-Installer"><br>到这里<code>windows</code>下的安装就基本结束了</p>
<h3 id="Ubuntu-18下安装MySQL"><a href="#Ubuntu-18下安装MySQL" class="headerlink" title="Ubuntu 18下安装MySQL"></a>Ubuntu 18下安装MySQL</h3><p>在<code>Ubuntu 18</code>下，如果你没有版本的要求，则可以直接在命令行输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update  #更新软件源</span><br><span class="line">sudo apt-get install mysql-server  #安装mysql</span><br></pre></td></tr></tbody></table></figure>
<p>上述命令会安装以下包：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">apparmor</span><br><span class="line">mysql-client-5.7</span><br><span class="line">mysql-common</span><br><span class="line">mysql-server</span><br><span class="line">mysql-server-5.7</span><br><span class="line">mysql-server-core-5.7</span><br></pre></td></tr></tbody></table></figure>
<p>因此无需再安装<code>mysql-client</code>等。安装过程会提示设置<code>mysql</code> <code>root</code>用户的密码，设置完成后等待自动安装即可。默认安装完成就启动了<code>mysql</code>。启动MySQL命令:<code>service mysql start</code>,关闭MySQL命令:<code>service mysql stop</code></p>
<h3 id="Ubuntu-18下安装MySQL-8-0"><a href="#Ubuntu-18下安装MySQL-8-0" class="headerlink" title="Ubuntu 18下安装MySQL 8.0"></a>Ubuntu 18下安装MySQL 8.0</h3><p>如果你必须要使用<code>MySQL 8</code>,则需要执行以下命令删除已有的<code>MySQL</code>以及其依赖</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get remove mysql-common</span><br><span class="line">sudo apt-get autoremove --purge mysql-server-5.7 #最后的版本数字根据自己具体的版本进行相应的修改</span><br><span class="line">dpkg -l|grep ^rc|awk '{print$2}'|sudo xargs dpkg -P</span><br><span class="line">sudo apt-get autoremove --purge mysql-apt-config</span><br></pre></td></tr></tbody></table></figure>
<p>接下来就是安装存储库软件包，需要使用上一章中下载的<code>mysql-apt-config_0.8.16-1_all.deb</code>,如果你没有下载可以去官网下载，下载后需要将其上传到服务器<br>也可以直接使用命令直接下载到服务器上</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">wget -c https://repo.mysql.com//mysql-apt-config_0.8.16-1_all.deb</span><br></pre></td></tr></tbody></table></figure>
<p>接下来使用命令安装上一步下载的安装包</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo dpkg -i mysql-apt-config_0.8.16-1_all.deb</span><br></pre></td></tr></tbody></table></figure>
<p>安装过程中提示选择安装版本，默认安装的就是8.0版本，所以直接选择“OK”确认即可，安装完成后同样执行:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update  #更新软件源</span><br><span class="line">sudo apt-get install mysql-server  #安装mysql</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>重学MySQL</category>
        <category>下载并安装MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>重学MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《重学MySQL》MySQL的启动以及启动参数</title>
    <url>/2020/11/17/MySQL/%E9%87%8D%E5%AD%A6MySQL/%E5%90%AF%E5%8A%A8Mysql/MySQL%E7%9A%84%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8A%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p><img src="http://files.codedog.link/blog/typecho/mysql.jpg" alt="MySQL"></p>
<a id="more"></a>

<p><code>MySQL</code>的安装以及结束，接下来就要启动<code>MySQL</code>了，在启动之前，我们先打开安装好的<code>MySQL</code>目录看一下其有哪些可运行的程序，博主用的是<code>windows</code>操作系统，我的安装目录是<code>C:\Program Files\MySQL\MySQL Server 5.7</code>，如果你的和我不一样，可以打开你自己的目录。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">bin     # 存放可执行文件</span><br><span class="line">docs    # 存放一些文档</span><br><span class="line">include # 存放一些头文件，如：mysql.h、mysql_ername.h等。</span><br><span class="line">lib     # 存放一系列库文件。</span><br><span class="line">share   # 存放字符集、语言等信息。</span><br><span class="line">LICENSE # 放在文本文档中打开看是啥 </span><br><span class="line">README  # 放在文本文档中打开看是啥 </span><br></pre></td></tr></tbody></table></figure>
<p>上面以及表明了每个目录的作用，既然我们要运行<code>MySQL</code>，就打开<code>bin</code>目录，看看它下面有存放着哪些可执行程序:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">innochecksum.exe                    # 脱机innodb数据文件校验和检查</span><br><span class="line">lz4_decompress.exe                  # 用来解压缩 mysqlpump的LZ4压缩输出（说实话没关注过，后面博主会了解下）</span><br><span class="line">myisamchk.exe                       # 可以用来获得有关你的数据库表的统计信息或检查、修复、优化他们</span><br><span class="line">myisamlog.exe                       # 显示MyISAM日志文件内容</span><br><span class="line">myisampack.exe                      # 可以压缩MyISAM表</span><br><span class="line">myisam_ftdump.exe                   # 显示全文索引信息。</span><br><span class="line">mysql.exe                           # mysql客户端，用来连接并操作mysql服务的 （黑黑的那个窗口）</span><br><span class="line">mysqladmin.exe                      # 用于管理MySQL服务器客户端，修改密码等功能。</span><br><span class="line">mysqlbinlog.exe                     # 处理二进制日志文件的。</span><br><span class="line">mysqlcheck.exe                      # 表维护程序。</span><br><span class="line">mysqld.exe                          # mysql的服务端，我们口头意义上的连接mysql就是连接它.</span><br><span class="line">mysqldump.exe                       # 数据库备份程序。</span><br><span class="line">mysqlimport.exe                     # 数据导入程序。</span><br><span class="line">mysqlpump.exe                       # 数据库备份程序，比mysqldump更强。</span><br><span class="line">mysqlshow.exe                       # 显示数据库、表和列的信息。</span><br><span class="line">mysqlslap.exe                       # 负载仿真客户端。</span><br><span class="line">mysql_config_editor.exe             # MySQL的配置实用程序（后面会讲到）。</span><br><span class="line">mysql_embedded.exe</span><br><span class="line">mysql_plugin.exe                    # 配置MySQL服务器插件。</span><br><span class="line">mysql_secure_installation.exe       # 提高MySQL安装的安全性。</span><br><span class="line">mysql_ssl_rsa_setup.exe             # 创建 SSL/RSA 文件。</span><br><span class="line">mysql_tzinfo_to_sql.exe             # 加载时区表。</span><br><span class="line">mysql_upgrade.exe                   # 检查并升级MySQL表。</span><br><span class="line">my_print_defaults.exe               # 显示选项文件的选项。</span><br><span class="line">perror.exe                          # 解释错误代码。</span><br><span class="line">resolveip.exe                       # 解析主机名到IP地址或反之亦然。</span><br><span class="line">zlib_decompress.exe                 # 解压缩mysqlpump zlib压缩输出。</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>文章写了一半，博主突然脑子一热给自己笔记本装了黑苹果，后面的文章可能就要以<code>MacOS</code>作为演示平台了😂<br>这里博主再展示下在<code>MacOS</code>下的<code>MySQL</code>文件目录结构</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">lrwxr-xr-x   1 root  wheel         36 11 19 20:15 libprotobuf-lite.3.11.4.dylib -&gt; ../lib/libprotobuf-lite.3.11.4.dylib</span><br><span class="line">lrwxr-xr-x   1 root  wheel         31 11 19 20:15 libprotobuf.3.11.4.dylib -&gt; ../lib/libprotobuf.3.11.4.dylib</span><br><span class="line">-rwxr-xr-x   1 root  wheel    6954720  9 25 05:44 lz4_decompress</span><br><span class="line">-rwxr-xr-x   1 root  wheel    6878176  9 25 05:44 my_print_defaults</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7226816  9 25 05:44 myisam_ftdump</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7399536  9 25 05:44 myisamchk</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7175712  9 25 05:44 myisamlog</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7261536  9 25 05:44 myisampack</span><br><span class="line">-rwxr-xr-x   1 root  wheel    8313088  9 25 05:44 mysql</span><br><span class="line">-rwxr-xr-x   1 root  wheel       5023  9 25 03:48 mysql_config</span><br><span class="line">-rwxr-xr-x   1 root  wheel    6899536  9 25 05:44 mysql_config_editor</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7940400  9 25 05:44 mysql_secure_installation</span><br><span class="line">-rwxr-xr-x   1 root  wheel    6939104  9 25 05:44 mysql_ssl_rsa_setup</span><br><span class="line">-rwxr-xr-x   1 root  wheel    6803536  9 25 05:44 mysql_tzinfo_to_sql</span><br><span class="line">-rwxr-xr-x   1 root  wheel    8186544  9 25 05:44 mysql_upgrade</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7951296  9 25 05:44 mysqladmin</span><br><span class="line">-rwxr-xr-x   1 root  wheel    8582480  9 25 05:44 mysqlbinlog</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7969328  9 25 05:44 mysqlcheck</span><br><span class="line">-rwxr-xr-x   1 root  wheel   73581760  9 25 05:44 mysqld</span><br><span class="line">-rwxr-xr-x   1 root  wheel  269357824  9 25 05:44 mysqld-debug</span><br><span class="line">-rwxr-xr-x   1 root  wheel      27513  9 25 03:48 mysqld_multi</span><br><span class="line">-rwxr-xr-x   1 root  wheel      29164  9 25 03:48 mysqld_safe   # 我是启动脚本</span><br><span class="line">-rwxr-xr-x   1 root  wheel    8051216  9 25 05:44 mysqldump</span><br><span class="line">-rwxr-xr-x   1 root  wheel       7690  9 25 03:48 mysqldumpslow</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7950928  9 25 05:44 mysqlimport</span><br><span class="line">-rwxr-xr-x   1 root  wheel    9011456  9 25 05:44 mysqlpump</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7941824  9 25 05:44 mysqlshow</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7973312  9 25 05:44 mysqlslap</span><br><span class="line">-rwxr-xr-x   1 root  wheel    7597712  9 25 05:44 perror</span><br><span class="line">-rwxr-xr-x   1 root  wheel    6831648  9 25 05:44 zlib_decompress</span><br></pre></td></tr></tbody></table></figure>
<p>上面就是<code>bin</code>目录下可执行程序以及其作用，这里有很多我们不太需要去关注，目前只需要关注几个可执行程序：</p>
<h3 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h3><p><code>mysqld</code>这个文件就是<code>MySQL</code>服务器程序，运行这个文件就可以直接启动一个<code>MySQL</code>服务进程。</p>
<h3 id="mysqld-safe"><a href="#mysqld-safe" class="headerlink" title="mysqld_safe"></a>mysqld_safe</h3><p><code>mysqld_safe</code>脚本会在启动MySQL服务器后继续监控其运行情况，并在其死机时重新启动它。它通常做如下事情：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">检查系统和选项。</span><br><span class="line">检查MyISAM表。</span><br><span class="line">保持MySQL服务器窗口。</span><br><span class="line">启动并监视mysqld，如果因错误终止则重启。</span><br><span class="line">将mysqld的错误消息发送到数据目录中的host_name.err 文件。</span><br><span class="line">将mysqld_safe的屏幕输出发送到数据目录中的host_name.safe文件。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="mysqld-multi"><a href="#mysqld-multi" class="headerlink" title="mysqld_multi"></a>mysqld_multi</h3><p><code>mysql</code>多实例，捡来理解就是在一台服务器上，运行多个<code>mysql</code>服务进程，这些<code>mysql</code>服务进程通过不同的socket来监听不同的数据端口，进而互不干涉的提供各自的服务</p>
<h3 id="mysql-server"><a href="#mysql-server" class="headerlink" title="mysql.server"></a>mysql.server</h3><p><code>mysql.server</code>同样是服务端启动脚本，主要作用就是为了方便启动和关闭<code>mysql</code>服务，这个脚本会调用<code>mysql_safe</code>来启动<code>mysql</code>,需要注意的是这个文件并不在<code>bin</code>目录下，它的实际目录是安装目录的<code>support-files</code>文件夹下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/usr/local/mysql                               # 我的mysql安装目录</span><br><span class="line">/usr/local/mysql/support-files/mysql.server    # mysql.server文件位置</span><br></pre></td></tr></tbody></table></figure>

<h3 id="启动MySQL服务端"><a href="#启动MySQL服务端" class="headerlink" title="启动MySQL服务端"></a>启动MySQL服务端</h3><p>在<code>MacOS</code>下我使用如下命令启动<code>MySQL</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo /usr/local/mysql/support-files/mysql.server start   # 启动MySQL</span><br><span class="line">sudo /usr/local/mysql/support-files/mysql.server stop   # 停止MySQL</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在Windows下可以在cmd中输入以下命令启动mysql，当然前提是你已经把mysql注册为服务了</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">net start MySQL # 启动MySQL</span><br><span class="line">net stop MySQL  # 停止MySQL</span><br><span class="line"></span><br><span class="line">"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld" --install # 用于注册服务</span><br></pre></td></tr></tbody></table></figure>
<h3 id="启动MySQL客户端"><a href="#启动MySQL客户端" class="headerlink" title="启动MySQL客户端"></a>启动MySQL客户端</h3><p>成功启动MySQL服务后，就可以运行客户端连接到启动的服务器了，MySQL的bin目录下也为我们提供了一系列的客户端程序,比如：<br><code>mysqladmin</code>、<code>mysqldump</code>、<code>mysql</code>等等，这里博主先重点介绍一下<code>mysql</code>，通过这个可执行文件可以让我们和刚刚启动的数据库服务程序进行交互，启动这个文件时需要一些参数，比如连接的服务器ip、端口、账号、密码，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql -h [ip地址] -P [端口] -u [用户名] -p[密码]</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意：这里的参数<code>h、P、u、p</code>都是短形式的参数，参数p与值之间不能有空格，其余参数没有强制要求，还有这里的参数区分大小写，比如答谢的P代表的是端口号而小写的p是指密码。</p>
</blockquote>
<p>如果是服务器程序和客户端程序在一台电脑上（就像我们现在这样），可以省略掉部分参数，就像下面这样</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql -u[用户名] -p[密码]</span><br></pre></td></tr></tbody></table></figure>
<p>而mysql默认有一个用户名为<code>root</code>的用户，密码就是安装的时候设置的密码我们可以使用上面的命令尝试和服务程序进行连接</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">lu@ludeMacBook-Pro bin % sudo ./mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 11</span><br><span class="line">Server version: 8.0.22 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br></pre></td></tr></tbody></table></figure>
<p>这里可以看到，博主的命令<code>-p</code>后面并没有输入密码，这是mysql为了防止在你输入密码的时候，身边有其他人而你恰好不想让他看到你的密码。<br>如果我们想断开客户端与服务器的连接，可以在<code>mysql&gt;</code>后输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">quit</span><br><span class="line">exit</span><br><span class="line">\q</span><br></pre></td></tr></tbody></table></figure>
<p>上面三个命令其中任意一个都可以断开客户端与服务端的连接并且关闭客户端，这里我们尝试输入<code>exit</code>:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; exit</span><br><span class="line">Bye</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意，这里只是关闭客户端与服务器的连接，并不是关闭服务器哦</p>
</blockquote>
<h3 id="客户端和服务器通讯"><a href="#客户端和服务器通讯" class="headerlink" title="客户端和服务器通讯"></a>客户端和服务器通讯</h3><p>mysql客户端和服务器之间的通讯协议是“半双工”的，这意味着，在任何一个时刻，要么由服务器向客户端发送数据，要么由客户端向服务器发送数据，这两个动作不能同时发生。这种协议让mysql通信简单快速，但也限制了mysql。一个明显的限制是，这意味着没办法进行流量限制。一旦一端开始发生消息，另一端要接收完整个消息才能响应他。<br>客户端用一个单独的数据包将查询传给服务器。一旦客户端发送了请求，他能做的事情就只是等待结果了。<br>相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整的接受整个返回结果，而不是简单的只收取前面几条结果，然后让服务器停止发送数据。<br>多数连接mysql的库函数都可以获得全部结果并缓存到内存里，还可以逐行获取所需要的数据。默认一般是获得全部结果并缓存到内存中。mysql通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接受全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放对应的资源。</p>
<h3 id="服务器处理客户端的流程"><a href="#服务器处理客户端的流程" class="headerlink" title="服务器处理客户端的流程"></a>服务器处理客户端的流程</h3><p>在日常执行mysql语句的过程中,都是客户端进程向服务器进程发送一段文本(MySQL语句),服务器进程处理后再向客户端进程发送一段文本(处理结果). 看似很简单,其实不然,这内容有很多东西是需要注意的.下面用一张图来说明.<br><img src="http://files.codedog.link/blog/typecho/mysql%E5%9B%BE%E4%BE%8B.jpg"><br>用文字说明一下上面图片中的内容：</p>
<ul>
<li>客户端发送一条查询给服务器</li>
<li>服务器先到查询缓存中查询，如果命中了缓存，则立刻返回存储在缓存中的结果，否则继续往下执行</li>
<li>服务器对sql进行解析、预处理、在优化器生存对应的执行计划</li>
<li>执行引擎根据生成的执行计划调用存储引擎来执行查询</li>
<li>将结果返回给客户端</li>
</ul>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>数据库存储引擎是数据库底层软件模块，它提供创建、查询、更新和删除等操作，不同的存储引擎提供不同的存储机制，所采用的存取算法也可能不同。而使用不同的存储引擎还可以获得特定的功能。在客户端中我们可以使用<code>show engines</code>来查看mysql支持的所有存储引擎</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎。</p>
</blockquote>
<h3 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h3><p>不同的存储引擎都有各自的特点，以适应不同的需求。如表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>MylSAM</th>
<th>MEMORY</th>
<th>InnoDB</th>
<th>Archive</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
</tr>
<tr>
<td>支持事务</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持树索引</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持哈希索引</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持数据缓存</td>
<td>No</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持外键</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<p>不过实际上我们常用的存储引擎也就两三种，这里给大家介绍一下</p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。</p>
<h4 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h4><p>所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>
<blockquote>
<p>吧啦吧啦了一通，自己看着其实也很头痛，大部分的内容其实没有必要都记住，只是让大家做个了解，如果有兴趣的话，可以自己再百度找篇博客深入了解下</p>
</blockquote>
<h3 id="设置和修改存储引擎的方法"><a href="#设置和修改存储引擎的方法" class="headerlink" title="设置和修改存储引擎的方法"></a>设置和修改存储引擎的方法</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 创建表时设定</span><br><span class="line">CREATE TABLE [表名] (id int, .....) ENGINE = [存储引擎]</span><br><span class="line"># 修改</span><br><span class="line">ALTER TABLE [表名] ENGINE = [存储引擎];</span><br></pre></td></tr></tbody></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好啦，到这里本篇博客就结束了，这篇博客我也写了两三天，中间查资料，修修改改，还给笔记本装了个黑苹果😂第一次一个系列去写文章，和平时的感觉完全是两样，中间需要查询的资料很多，当然对我的提升也是很大的，下面一章估计也会写个几天，慢慢来吧，加油！！！</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>重学MySQL</category>
        <category>MySQL的启动以及启动参数</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>重学MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS配置Java运行环境</title>
    <url>/2020/11/14/%E8%BF%90%E7%BB%B4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Linux/CentOS%E9%85%8D%E7%BD%AEJava%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>CentOS 7</li>
<li>jdk 1.8</li>
</ul>
</blockquote>
<h2 id="CentOS-7-jdk的安装"><a href="#CentOS-7-jdk的安装" class="headerlink" title="CentOS 7 jdk的安装"></a>CentOS 7 jdk的安装</h2><ol>
<li>清理系统默认自带的jdk<br>首先使用<code>rpm -qa | grep jdk</code>查看一家安装的jdk,然后使用<code>sudo yum remove XXX</code>(XXX)为上一个命令查询到的结果</li>
<li>安装jdk<br>使用<code>sudo rpm -ivh jdk-xxx-linux-x64.rpm</code> 进行安装,默认安装路径是：<code>/usr/java</code></li>
<li>添加环境变量<br>使用<code>sudo vim /etc/profile</code>命令编辑文件,在文件底部增加:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdkx.x.x_xx</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></tbody></table></figure>
使配置生效:<code>. /etc/profile</code></li>
</ol>
<h2 id="CentOS-7-tomcat的安装"><a href="#CentOS-7-tomcat的安装" class="headerlink" title="CentOS 7 tomcat的安装"></a>CentOS 7 tomcat的安装</h2><ol>
<li>到<code>tomcat</code>官网<code>https://tomcat.apache.org/</code>下载对应版本tomcat,这里使用的是<code>apache-tomcat-8.5.40.tar.gz</code></li>
<li>使用<code>tar -zxvf apache-tomcat-8.5.40.tar.gz</code>命令解压</li>
<li>添加环境变量 使用vim /etc/profile 编辑文件 在底部添加:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export TOMCAT_HOME=/usr/tomcat</span><br><span class="line">export CATALINA_HOME=/usr/tomcat</span><br></pre></td></tr></tbody></table></figure>
并在上面增加的<code>PATH</code>路径后面追加上<code>tomcat</code>的<code>bin</code>地址<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$TOMCAT_HOME/bin</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="ContOS-7-maven的配置"><a href="#ContOS-7-maven的配置" class="headerlink" title="ContOS 7 maven的配置"></a>ContOS 7 maven的配置</h2><ol>
<li>到<code>maven</code>官网<code>http://maven.apache.org</code>下载对应版本maven,这里使用的是<code>apache-maven-3.6.1-bin.tar.gz</code></li>
<li>使用<code>tar -zxvf apache-maven-3.6.1-bin.tar.gz</code>命令解压</li>
<li>添加环境变量 使用vim /etc/profile 编辑文件 在底部添加:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export MAVEN_HOME=/usr/maven</span><br></pre></td></tr></tbody></table></figure>
并在上面增加的<code>PATH</code>路径后面追加上<code>maven</code>的<code>bin</code>地址<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$TOMCAT_HOME/bin:$MAVEN_HOME/bin</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="ContOS-7-vsftpd配置"><a href="#ContOS-7-vsftpd配置" class="headerlink" title="ContOS 7 vsftpd配置"></a>ContOS 7 vsftpd配置</h2><ol>
<li><p>查看是否安装了vsftpd</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qa | grep vsftpd</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>安装vsftpd</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y vsftpd</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>新建ftp根目录</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mkdir /ftproot</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>添加一个ftp用户并设置主目录并指定文件的拥有者,和禁止ssh连接(useradd xxx)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">useradd testftp -d /ftproot/testftp/ -s /sbin/nologin</span><br><span class="line"># 或者</span><br><span class="line">useradd testftp -s /sbin/nologin</span><br><span class="line">usermod testftp -d /ftproot/testftp/</span><br><span class="line"># 指定文件拥有者为创建的用户:</span><br><span class="line">sudo chown -R testftp.testftp ./testftp/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>给ftp用户添加密码(passwd xxx)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo passwd testftp</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>防火墙开放21端口</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>防火墙添加FTP服务</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=ftp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>无法连接ftp解决办法:</p>
<blockquote>
<ul>
<li>查看ftp的Selinux状态：<code>getsebool -a | grep ftp</code></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ftpd_anon_write --&gt; off</span><br><span class="line">ftpd_connect_all_unreserved --&gt; off</span><br><span class="line">ftpd_connect_db --&gt; off</span><br><span class="line">ftpd_full_access --&gt; off</span><br><span class="line">ftpd_use_cifs --&gt; off</span><br><span class="line">ftpd_use_fusefs --&gt; off</span><br><span class="line">ftpd_use_nfs --&gt; off</span><br><span class="line">ftpd_use_passive_mode --&gt; off</span><br><span class="line">httpd_can_connect_ftp --&gt; off</span><br><span class="line">httpd_enable_ftp_server --&gt; off</span><br><span class="line">tftp_anon_write --&gt; off</span><br><span class="line">tftp_home_dir --&gt; off</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<ul>
<li>在结果中可以看到:<code>tftp_home_dir --&gt; off</code>、<code>ftpd_full_access --&gt; off</code></li>
<li>将状态改为on:<code>setsebool -P tftp_home_dir on</code>、<code>setsebool -P ftpd_full_access on</code></li>
<li>重启vsftpd服务:<code>systemctl restart vsftpd.service</code></li>
<li>重启firewall服务:<code>systemctl restart firewalld.service</code></li>
</ul>
</blockquote>
</li>
<li><p>开启ftp被动模式</p>
<blockquote>
<ul>
<li>打开vsftpd.conf文件，在后面加上</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">pasv_min_port=30000</span><br><span class="line">pasv_max_port=30999</span><br></pre></td></tr></tbody></table></figure>
<p>并开放30000-30999端口</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=30000-30999/tcp --permanent </span><br><span class="line">firewall-cmd --zone=public --add-port=30000-30999/udp --permanent </span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置开机启动vsftpd</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">systemctl enable vsftpd.service</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>不允许用户切出当前目录(只有在chroot_list_file指定的文件中出现的用户才能切换到上级目录)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=NO</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>ftpusers和user_list&nbsp; 文件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">vsftpd有两个默认存放用户名单的文件（默认在/etc/vsftpd/ 目录下），来对访问FTP服务的用户身份进行管理和限制。</span><br><span class="line">vsftpd会分别检查两个配置文件，只要是被任何一个文件所禁止的用户，FTP访问到本机的请求都会被拒。</span><br><span class="line"></span><br><span class="line">user_list：可以作为用户白名单，或者是黑名单，或者无效名单。完全由userlist_enable和userlist_deny这两个参数决定。</span><br><span class="line">ftpusers：只能是用户黑名单，不受任何参数限制。</span><br><span class="line"></span><br><span class="line"> userlist_enable和userlist_deny参数</span><br><span class="line">决定user_list文件性质的参数 userlist_enable和userlist_deny</span><br><span class="line"></span><br><span class="line">(vsftpd服务程序的主配置文件默认位置 /etc/vsftpd/vsftpd.conf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">userlist_enable=YES   userlist_deny=YES  黑名单，拒绝文件中的用户FTP访问</span><br><span class="line"> </span><br><span class="line">userlist_enable=YES   userlist_deny=NO   白名单，拒绝除文件中的用户外的用户FTP访问</span><br><span class="line"> </span><br><span class="line">userlist_enable=NO   userlist_deny=YES/NO  无效名单，表示没有对任何用户限制FTP访问</span><br><span class="line"></span><br><span class="line">总之，要想让user_list有效，userlist_enable=YES</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>==注意！！！！ 一定要把<code>/etc/pam.d/vsftpd</code>文件中的 auth       required    pam_shells.so给注释掉,否则会检查当前用户是否有登录ssh的权限,为nologin的用户会无法连接ftp==</p>
</blockquote>
</li>
</ol>
<h2 id="ContOS-7-安装nginx"><a href="#ContOS-7-安装nginx" class="headerlink" title="ContOS 7 安装nginx"></a>ContOS 7 安装nginx</h2><ol>
<li>安装nginx所需要的依赖环境<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># gcc</span><br><span class="line">sudo yum install gcc-c++</span><br><span class="line"># pcre</span><br><span class="line">sudo yum install pcre pcre-devel</span><br><span class="line"># zlib</span><br><span class="line">sudo yum install -y zlib zlib-devel</span><br><span class="line"># openssl</span><br><span class="line">sudo yum install openssl openssl-devel</span><br></pre></td></tr></tbody></table></figure></li>
<li>到<code>nginx</code>官网<code>http://nginx.org/en/download.html</code>下载nginx,并使用命令行解压、安装<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.15.12.tar.gz </span><br><span class="line">cd nginx-1.15.12/</span><br><span class="line">sudo ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<p>3.<code>nginx</code>常用命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nginx -s reload  ：修改配置后重新加载生效</span><br><span class="line">nginx -s reopen  ：重新打开日志文件</span><br><span class="line">nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确</span><br><span class="line"></span><br><span class="line">关闭nginx：</span><br><span class="line">nginx -s stop  :快速停止nginx</span><br><span class="line">         quit  ：完整有序的停止nginx</span><br><span class="line"></span><br><span class="line">其他的停止nginx 方式：</span><br><span class="line"></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line">kill -QUIT 主进程号     ：从容停止Nginx</span><br><span class="line">kill -TERM 主进程号     ：快速停止Nginx</span><br><span class="line">pkill -9 nginx          ：强制停止Nginx</span><br><span class="line"></span><br><span class="line">启动nginx:</span><br><span class="line">nginx -c /path/to/nginx.conf</span><br><span class="line"></span><br><span class="line">平滑重启nginx：</span><br><span class="line">kill -HUP 主进程号</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>配置<code>nginx</code></li>
</ol>
<ul>
<li><p>首先在<code>conf</code>目录的<code>nginx.conf</code>中server:{}结尾后添加一行:<code>include vhost/*.conf;</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">#user  nobody;  如果访问文件服务器  这里修改为ftp的用户名  可以解决403</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events {</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">    #                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html {</span><br><span class="line">            root   html;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ {</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ {</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache's document root</span><br><span class="line">        # concurs with nginx's one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht {</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #}</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ##########################vhost#####################################</span><br><span class="line">    include vhost/*.conf;  #这里添加一行!!!!!</span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server {</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / {</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    }</span><br><span class="line">    #}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server {</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / {</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    }</span><br><span class="line">    #}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>然后新建一个<code>vhost</code>文件夹,里面可以放置<code>*.conf</code>的配置文件,两个简单的配置示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> # 配置反向代理到指定端口</span><br><span class="line"> server {</span><br><span class="line">    listen 80;</span><br><span class="line">    autoindex on;</span><br><span class="line">    server_name codedog.link;</span><br><span class="line">    access_log /usr/local/nginx/logs/access.log combined;</span><br><span class="line">    index index.html index.htm index.jsp index.php;</span><br><span class="line">    if ( $query_string ~* ".*[\;'\&lt;\&gt;].*" ){</span><br><span class="line">        return 404;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"># 配置反向代理到指定目录</span><br><span class="line">server {</span><br><span class="line">    listen 80;</span><br><span class="line">    autoindex off;</span><br><span class="line">    server_name codedog.link;</span><br><span class="line">    access_log /usr/local/nginx/logs/access.log combined;</span><br><span class="line">    index index.html index.htm index.jsp index.php;</span><br><span class="line">    #error_page 404 /404.html;</span><br><span class="line">    if ( $query_string ~* ".*[\;'\&lt;\&gt;].*" ){</span><br><span class="line">        return 404;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        root /product/ftpfile/img/;</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h2 id="ContOS-7-配置开放端口"><a href="#ContOS-7-配置开放端口" class="headerlink" title="ContOS 7 配置开放端口"></a>ContOS 7 配置开放端口</h2><p>ContOS 7 的防火墙是：<code>firewalld</code></p>
<ul>
<li>基本用法：</li>
<li>启动： <code>systemctl start firewalld</code></li>
<li>查看状态： <code>systemctl status firewalld</code> </li>
<li>停止： <code>systemctl disable firewalld</code></li>
<li>禁用： <code>systemctl stop firewalld</code></li>
<li>添加一个端口: <code>firewall-cmd --zone=public --add-port=80/tcp --permanent    （--permanent永久生效，没有此参数重启后失效）</code></li>
<li>重新载入:<code>firewall-cmd --reload</code></li>
<li>查看:<code>firewall-cmd --zone= public --query-port=80/tcp</code></li>
<li>删除:<code>firewall-cmd --zone= public --remove-port=80/tcp --permanent</code></li>
</ul>
<h2 id="ContOS-7-安装mysql"><a href="#ContOS-7-安装mysql" class="headerlink" title="ContOS 7 安装mysql"></a>ContOS 7 安装mysql</h2><ol>
<li>打开<code>mysql</code>官网<code>https://www.mysql.com/</code>下载对应版本yum源的安装包</li>
<li>把下载的安装包上传到<code>CentOS</code>服务器上</li>
<li>执行命令:<code>yum install mysql-community-server</code></li>
<li>安装完成后使用命令:<code>service mysqld start</code>启动mysql</li>
<li>mysql启动后使用<code>grep 'temporary password' /var/log/mysqld.log</code>查看安装时默认设置的密码</li>
<li>使用命令:<code>ALTER USER 'root'@'localhost' IDENTIFIED BY 'newpassword';</code>修改默认密码</li>
<li>把root的登录地址修改为任意地址: <code>update user set host =’%' where user =’root’;</code></li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>Linux</tag>
        <tag>ContOS</tag>
      </tags>
  </entry>
  <entry>
    <title>NGINX配置HTTPS</title>
    <url>/2020/11/14/%E8%BF%90%E7%BB%B4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/nginx/NGINX%E9%85%8D%E7%BD%AEHTTPS/</url>
    <content><![CDATA[<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置:"></a>nginx配置:</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">upstream tomcat {</span><br><span class="line">    server 127.0.0.1:8080 fail_timeout=0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># HTTPS server</span><br><span class="line">server {</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  codedog.link;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      server.crt;</span><br><span class="line">    ssl_certificate_key  server.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_connect_timeout      240;</span><br><span class="line">        proxy_send_timeout         240;</span><br><span class="line">        proxy_read_timeout         240;</span><br><span class="line">        # note, there is not SSL here! plain HTTP is used</span><br><span class="line">        proxy_pass http://tomcat;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="nginx-80端口-转443端口"><a href="#nginx-80端口-转443端口" class="headerlink" title="nginx 80端口 转443端口"></a>nginx 80端口 转443端口</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line"> </span><br><span class="line">        listen 80;</span><br><span class="line"> </span><br><span class="line">        server_name codedog.link;</span><br><span class="line"> </span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>运维</category>
        <category>环境配置</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>nginx</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
</search>
